import { gql } from '@apollo/client';
import * as ApolloReactCommon from '@apollo/client';
import * as ApolloReactHooks from '@apollo/client/react';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** An ISO 8601-encoded date */
  ISO8601Date: { input: any; output: any; }
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: { input: any; output: any; }
  /** Represents untyped JSON */
  JSON: { input: Record<string, unknown>; output: Record<string, unknown>; }
  Upload: { input: any; output: any; }
};

/** Autogenerated input type of AbandonSession */
export type AbandonSessionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the session to abandon */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of AbandonSession. */
export type AbandonSessionPayload = {
  __typename?: 'AbandonSessionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The abandoned session with updated status */
  session: OnboardingSession;
  /** Indicates if the abandonment was successful */
  success: Scalars['Boolean']['output'];
};

/** Appointment information */
export type Appointment = {
  __typename?: 'Appointment';
  /** Whether appointment can be cancelled */
  cancellable: Scalars['Boolean']['output'];
  /** Reason for cancellation */
  cancellationReason: Maybe<Scalars['String']['output']>;
  /** When appointment was cancelled */
  cancelledAt: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Confirmation number for appointment */
  confirmationNumber: Scalars['String']['output'];
  /** When appointment was confirmed */
  confirmedAt: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** When appointment was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Duration in minutes */
  durationMinutes: Scalars['Int']['output'];
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Location type (virtual or in_person) */
  locationType: Scalars['String']['output'];
  /** Associated onboarding session ID */
  onboardingSessionId: Scalars['ID']['output'];
  /** Whether appointment can be rescheduled */
  reschedulable: Scalars['Boolean']['output'];
  /** Scheduled date and time */
  scheduledAt: Scalars['ISO8601DateTime']['output'];
  /** Appointment status (scheduled, confirmed, cancelled, completed, no_show) */
  status: Scalars['String']['output'];
  /** Therapist for this appointment */
  therapist: Therapist;
  /** When appointment was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
  /** Virtual meeting link for online appointments */
  virtualLink: Maybe<Scalars['String']['output']>;
};

/** Mental health screening assessment (PHQ-A, GAD-7) */
export type Assessment = {
  __typename?: 'Assessment';
  /** Assessment mode (conversational or legacy) */
  assessmentMode: Maybe<Scalars['String']['output']>;
  /** Number of completed questions */
  completedQuestionsCount: Scalars['Int']['output'];
  /** Whether consent was given */
  consentGiven: Scalars['Boolean']['output'];
  /** When assessment was started */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Current instrument being administered */
  currentInstrument: Maybe<Scalars['String']['output']>;
  /** Whether GAD-7 is complete */
  gad7Complete: Scalars['Boolean']['output'];
  /** GAD-7 anxiety score (0-21) */
  gad7Score: Maybe<Scalars['Int']['output']>;
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Next question identifier */
  nextQuestionId: Maybe<Scalars['String']['output']>;
  /** Whether PHQ-A is complete */
  phqAComplete: Scalars['Boolean']['output'];
  /** PHQ-A depression score (0-27) */
  phqAScore: Maybe<Scalars['Int']['output']>;
  /** Completion percentage (0-100) */
  progressPercentage: Scalars['Int']['output'];
  /** Assessment responses (encrypted PHI) */
  responses: Scalars['JSON']['output'];
  /** Identified risk flags */
  riskFlags: Array<Scalars['String']['output']>;
  /** Combined assessment score (0-100) */
  score: Maybe<Scalars['Int']['output']>;
  /** Assessment status (not_started, in_progress, complete) */
  status: Scalars['String']['output'];
  /** AI-generated clinical summary (encrypted PHI) */
  summary: Maybe<Scalars['String']['output']>;
  /** Total questions (16) */
  totalQuestionsCount: Scalars['Int']['output'];
  /** When assessment was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Assessment progress information */
export type AssessmentProgress = {
  __typename?: 'AssessmentProgress';
  /** Number of completed questions */
  completedQuestions: Scalars['Int']['output'];
  /** Current phase (not_started, phq_a, gad_7, complete) */
  currentPhase: Scalars['String']['output'];
  /** Whether GAD-7 is complete */
  gad7Complete: Scalars['Boolean']['output'];
  /** Progress percentage (0-100) */
  percentage: Scalars['Int']['output'];
  /** Whether PHQ-A is complete */
  phqAComplete: Scalars['Boolean']['output'];
  /** Assessment status (not_started, in_progress, complete) */
  status: Scalars['String']['output'];
  /** Total questions (16) */
  totalQuestions: Scalars['Int']['output'];
};

/** A screening assessment question */
export type AssessmentQuestion = {
  __typename?: 'AssessmentQuestion';
  /** Clinical domain (e.g., anhedonia, anxious) */
  domain: Scalars['String']['output'];
  /** Question ID (e.g., phq_a_1) */
  id: Scalars['String']['output'];
  /** Instrument name (PHQ-A or GAD-7) */
  instrument: Scalars['String']['output'];
  /** Item number (1-9 for PHQ-A, 1-7 for GAD-7) */
  item: Scalars['Int']['output'];
  /** Question text */
  text: Scalars['String']['output'];
};

/** Autogenerated return type of AssessmentUpdated. */
export type AssessmentUpdatedPayload = {
  __typename?: 'AssessmentUpdatedPayload';
  /** Completed questions */
  completedQuestionsCount: Scalars['Int']['output'];
  /** Current instrument */
  currentInstrument: Maybe<Scalars['String']['output']>;
  /** GAD-7 complete */
  gad7Complete: Scalars['Boolean']['output'];
  /** GAD-7 score (when complete) */
  gad7Score: Maybe<Scalars['Int']['output']>;
  /** Assessment ID */
  id: Scalars['ID']['output'];
  /** Next question ID */
  nextQuestionId: Maybe<Scalars['String']['output']>;
  /** PHQ-A complete */
  phqAComplete: Scalars['Boolean']['output'];
  /** PHQ-A score (when complete) */
  phqAScore: Maybe<Scalars['Int']['output']>;
  /** Completion percentage */
  progressPercentage: Scalars['Int']['output'];
  /** Assessment status */
  status: Scalars['String']['output'];
  /** Total questions */
  totalQuestionsCount: Scalars['Int']['output'];
};

/** A date with its available time slots */
export type AvailableDate = {
  __typename?: 'AvailableDate';
  /** The date (YYYY-MM-DD) */
  date: Scalars['ISO8601Date']['output'];
  /** Whether there are any available slots on this date */
  hasAvailability: Scalars['Boolean']['output'];
  /** List of available time slots for this date */
  slots: Array<AvailableSlot>;
};

/** An available appointment time slot */
export type AvailableSlot = {
  __typename?: 'AvailableSlot';
  /** End time of the slot */
  endTime: Scalars['ISO8601DateTime']['output'];
  /** Unique identifier for the slot (formatted as therapist_id-datetime) */
  id: Scalars['ID']['output'];
  /** Whether the slot is currently available for booking */
  isAvailable: Scalars['Boolean']['output'];
  /** Start time of the slot */
  startTime: Scalars['ISO8601DateTime']['output'];
  /** Timezone of the slot times */
  timezone: Scalars['String']['output'];
};

/** Autogenerated input type of BookAppointment */
export type BookAppointmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Duration in minutes (defaults to therapist default) */
  durationMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Appointment date and time */
  scheduledAt: Scalars['ISO8601DateTime']['input'];
  /** Onboarding session ID (with or without sess_ prefix) */
  sessionId: Scalars['ID']['input'];
  /** Therapist ID */
  therapistId: Scalars['ID']['input'];
};

/** Autogenerated return type of BookAppointment. */
export type BookAppointmentPayload = {
  __typename?: 'BookAppointmentPayload';
  /** Created appointment */
  appointment: Maybe<Appointment>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Errors encountered during booking */
  errors: Array<Scalars['String']['output']>;
  /** Whether booking was successful */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of CancelAppointment */
export type CancelAppointmentInput = {
  /** Appointment ID to cancel */
  appointmentId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Reason for cancellation */
  reason?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CancelAppointment. */
export type CancelAppointmentPayload = {
  __typename?: 'CancelAppointmentPayload';
  /** Cancelled appointment */
  appointment: Maybe<Appointment>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Errors encountered during cancellation */
  errors: Array<Scalars['String']['output']>;
  /** Whether cancellation was successful */
  success: Scalars['Boolean']['output'];
};

/** Child information */
export type Child = {
  __typename?: 'Child';
  /** Child age calculated from date of birth */
  age: Maybe<Scalars['Int']['output']>;
  /** When record was created */
  created_at: Scalars['ISO8601DateTime']['output'];
  /** Child date of birth in ISO 8601 format (encrypted) */
  date_of_birth: Scalars['String']['output'];
  /** Child first name (encrypted) */
  first_name: Scalars['String']['output'];
  /** Child gender (optional) */
  gender: Maybe<Scalars['String']['output']>;
  /** Child current grade level (optional) */
  grade: Maybe<Scalars['String']['output']>;
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Child last name (encrypted) */
  last_name: Scalars['String']['output'];
  /** Primary concerns in parent own words (encrypted) */
  primary_concerns: Maybe<Scalars['String']['output']>;
  /** Name of child school (optional) */
  school_name: Maybe<Scalars['String']['output']>;
  /** When record was last updated */
  updated_at: Scalars['ISO8601DateTime']['output'];
};

/** Input for submitting child information */
export type ChildInput = {
  /** Child's date of birth in ISO 8601 format (YYYY-MM-DD) */
  date_of_birth: Scalars['String']['input'];
  /** Child's first name */
  first_name: Scalars['String']['input'];
  /** Child's gender (optional) */
  gender?: InputMaybe<Scalars['String']['input']>;
  /** Child's current grade level (optional) */
  grade?: InputMaybe<Scalars['String']['input']>;
  /** Child's last name */
  last_name: Scalars['String']['input'];
  /** Primary concerns in parent's own words (optional) */
  primary_concerns?: InputMaybe<Scalars['String']['input']>;
  /** Name of child's school (optional) */
  school_name?: InputMaybe<Scalars['String']['input']>;
};

/** Comparison table row showing insurance vs. self-pay */
export type ComparisonRow = {
  __typename?: 'ComparisonRow';
  /** Whether to highlight self-pay as the better value for this row */
  highlightSelfPay: Scalars['Boolean']['output'];
  /** Insurance cost for this item (null if not applicable) */
  insuranceValue: Maybe<Scalars['String']['output']>;
  /** Row label (e.g., 'Per Session Cost') */
  label: Scalars['String']['output'];
  /** Self-pay cost for this item */
  selfPayValue: Scalars['String']['output'];
};

/** Autogenerated input type of CompleteAssessment */
export type CompleteAssessmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Force transition even if some prerequisites are missing (for testing) */
  force?: InputMaybe<Scalars['Boolean']['input']>;
  /** The session ID */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of CompleteAssessment. */
export type CompleteAssessmentPayload = {
  __typename?: 'CompleteAssessmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  session: Maybe<OnboardingSession>;
  success: Scalars['Boolean']['output'];
};

/** Support contact options for parents requesting human assistance */
export type ContactOptions = {
  __typename?: 'ContactOptions';
  /** Chat availability hours with timezone */
  chatHours: Scalars['String']['output'];
  /** Support email address */
  email: Scalars['String']['output'];
  /** Support phone number */
  phone: Scalars['String']['output'];
};

/** A cost adjustment line item (fee, modifier, tax, or discount) */
export type CostAdjustment = {
  __typename?: 'CostAdjustment';
  /** Dollar amount of adjustment (positive for fees, negative for discounts) */
  amount: Scalars['Float']['output'];
  /** Human-readable description of the adjustment */
  description: Scalars['String']['output'];
  /** Percentage value if adjustment is percentage-based (e.g., 20 for 20%) */
  percentage: Maybe<Scalars['Float']['output']>;
  /** Adjustment type (duration_modifier, therapist_tier, special_service, tax, discount) */
  type: Scalars['String']['output'];
};

/** Cost calculation breakdown for a therapy session */
export type CostBreakdown = {
  __typename?: 'CostBreakdown';
  /** Array of cost adjustments (fees, modifiers, taxes, discounts) */
  adjustments: Array<CostAdjustment>;
  /** Timestamp when calculation was performed */
  calculatedAt: Scalars['ISO8601DateTime']['output'];
  /** Currency code (e.g., USD) */
  currency: Scalars['String']['output'];
  /** Whether the provided discount code was invalid (for user feedback) */
  discountCodeInvalid: Maybe<Scalars['Boolean']['output']>;
  /** Base cost before any adjustments */
  grossCost: Scalars['Float']['output'];
  /** Additional calculation metadata (service_type, duration, etc.) */
  metadata: Maybe<Scalars['JSON']['output']>;
  /** Final cost after all adjustments */
  netCost: Scalars['Float']['output'];
};

/** Cost comparison between insurance and self-pay options */
export type CostComparison = {
  __typename?: 'CostComparison';
  /** Side-by-side comparison rows */
  comparisonTable: Array<ComparisonRow>;
  /** True when self-pay is the better option */
  highlightSelfPay: Scalars['Boolean']['output'];
  /** Insurance cost estimate (null if insurance not verified) */
  insuranceEstimate: Maybe<InsuranceEstimate>;
  /** Personalized recommendation based on situation */
  recommendation: Maybe<Scalars['String']['output']>;
  /** Positive amount if self-pay is cheaper */
  savingsIfSelfPay: Maybe<Scalars['Float']['output']>;
  /** Self-pay cost estimate (always available) */
  selfPayEstimate: SelfPayEstimate;
};

/** Cost estimate for therapy session based on insurance coverage */
export type CostEstimate = {
  __typename?: 'CostEstimate';
  /** Allowed amount (contracted rate) for the service in USD */
  allowedAmount: Scalars['Float']['output'];
  /** Provider's standard billed amount in USD */
  billedAmount: Scalars['Float']['output'];
  /** When this estimate was calculated */
  calculatedAt: Scalars['ISO8601DateTime']['output'];
  /** Array of limitation messages (session limits, prior auth, etc.) */
  coverageLimitations: Array<Scalars['String']['output']>;
  /** Current deductible status information */
  deductibleStatus: DeductibleStatus;
  /** Standard disclaimer text explaining this is an estimate only */
  disclaimer: Scalars['String']['output'];
  /** Estimated amount insurance will pay in USD */
  insurancePays: Scalars['Float']['output'];
  /** Always true - indicates this is an estimate, not a guarantee */
  isEstimate: Scalars['Boolean']['output'];
  /** Estimated patient out-of-pocket responsibility in USD */
  patientPays: Scalars['Float']['output'];
};

/** Insurance coverage details for verified plans */
export type CoverageDetails = {
  __typename?: 'CoverageDetails';
  /** Coinsurance percentage, e.g., 20 for 20% */
  coinsurance: Maybe<Scalars['Int']['output']>;
  /** Copay amount formatted as currency, e.g., '$25 per visit' */
  copayAmount: Maybe<Scalars['String']['output']>;
  /** Deductible amount with met status, e.g., '$500 ($100 met)' */
  deductible: Maybe<Scalars['String']['output']>;
  /** Coverage effective date */
  effectiveDate: Maybe<Scalars['String']['output']>;
  /** List of covered services */
  servicesCovered: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateAvailability */
export type CreateAvailabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Day of week (0=Sunday, 1=Monday, ..., 6=Saturday) */
  dayOfWeek: Scalars['Int']['input'];
  /** End time (HH:MM format, e.g., 17:00) */
  endTime: Scalars['String']['input'];
  /** Whether this is a recurring weekly availability */
  isRepeating?: InputMaybe<Scalars['Boolean']['input']>;
  /** Start time (HH:MM format, e.g., 09:00) */
  startTime: Scalars['String']['input'];
  /** ID of the therapist */
  therapistId: Scalars['ID']['input'];
  /** IANA timezone (e.g., America/Los_Angeles) */
  timezone: Scalars['String']['input'];
};

/** Autogenerated return type of CreateAvailability. */
export type CreateAvailabilityPayload = {
  __typename?: 'CreateAvailabilityPayload';
  /** The created availability slot */
  availability: Maybe<TherapistAvailability>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** List of validation errors, if any */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated return type of CreateSession. */
export type CreateSessionPayload = {
  __typename?: 'CreateSessionPayload';
  /** Refresh token for obtaining new access tokens */
  refreshToken: Maybe<Scalars['String']['output']>;
  session: OnboardingSession;
  token: Scalars['String']['output'];
};

/** Autogenerated input type of CreateTherapist */
export type CreateTherapistInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Therapist profile data */
  input: TherapistInput;
};

/** Autogenerated return type of CreateTherapist. */
export type CreateTherapistPayload = {
  __typename?: 'CreateTherapistPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Validation errors if any */
  errors: Array<Scalars['String']['output']>;
  /** Whether creation was successful */
  success: Scalars['Boolean']['output'];
  /** Created therapist */
  therapist: Maybe<Therapist>;
};

/** Autogenerated input type of CreateTimeOff */
export type CreateTimeOffInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** End date of time-off */
  endDate: Scalars['ISO8601Date']['input'];
  /** Optional reason for time-off (e.g., vacation, conference) */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** Start date of time-off */
  startDate: Scalars['ISO8601Date']['input'];
  /** ID of the therapist */
  therapistId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreateTimeOff. */
export type CreateTimeOffPayload = {
  __typename?: 'CreateTimeOffPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** List of validation errors, if any */
  errors: Array<Scalars['String']['output']>;
  /** The created time-off period */
  timeOff: Maybe<TherapistTimeOff>;
};

/** Detailed deductible and out-of-pocket tracking information */
export type DeductibleStatus = {
  __typename?: 'DeductibleStatus';
  /** Total annual deductible amount in USD */
  amount: Scalars['Float']['output'];
  /** Source of deductible data: 'eligibility_api', 'manual_override', or 'cached' */
  dataSource: Maybe<Scalars['String']['output']>;
  /** Total annual deductible amount in dollars (alias for 'amount') */
  deductibleAmount: Maybe<Scalars['Float']['output']>;
  /** Amount of deductible already met this plan year (alias for 'met') */
  deductibleMet: Maybe<Scalars['Float']['output']>;
  /** Amount of deductible still owed before insurance covers services (alias for 'remaining') */
  deductibleRemaining: Maybe<Scalars['Float']['output']>;
  /** Whether this is a family plan (true) or individual plan (false) */
  isFamilyPlan: Maybe<Scalars['Boolean']['output']>;
  /** Whether the deductible has been fully met */
  isMet: Scalars['Boolean']['output'];
  /** When deductible data was last updated from eligibility check */
  lastUpdatedAt: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Amount of deductible met so far this year in USD */
  met: Scalars['Float']['output'];
  /** Total annual out-of-pocket maximum in dollars */
  oopMaxAmount: Maybe<Scalars['Float']['output']>;
  /** Amount already spent toward out-of-pocket maximum */
  oopMet: Maybe<Scalars['Float']['output']>;
  /** Percentage of out-of-pocket maximum met (0-100) */
  oopProgressPercentage: Maybe<Scalars['Int']['output']>;
  /** Amount remaining before out-of-pocket maximum is reached */
  oopRemaining: Maybe<Scalars['Float']['output']>;
  /** Percentage of deductible met (0-100) for visual progress indicator */
  progressPercentage: Maybe<Scalars['Int']['output']>;
  /** Amount of deductible remaining to be met in USD */
  remaining: Scalars['Float']['output'];
  /** Estimated number of therapy sessions until deductible is fully met */
  sessionsUntilDeductibleMet: Maybe<Scalars['Int']['output']>;
  /** Date when deductible and OOP max will reset for new plan year */
  yearResetDate: Maybe<Scalars['ISO8601DateTime']['output']>;
};

/** Autogenerated input type of DeleteAvailability */
export type DeleteAvailabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the availability slot to delete */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteAvailability. */
export type DeleteAvailabilityPayload = {
  __typename?: 'DeleteAvailabilityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** List of errors, if any */
  errors: Array<Scalars['String']['output']>;
  /** Whether the deletion was successful */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteTherapist */
export type DeleteTherapistInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Therapist ID to delete */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTherapist. */
export type DeleteTherapistPayload = {
  __typename?: 'DeleteTherapistPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Errors if any */
  errors: Array<Scalars['String']['output']>;
  /** Whether deletion was successful */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of DeleteTimeOff */
export type DeleteTimeOffInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the time-off period to delete */
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of DeleteTimeOff. */
export type DeleteTimeOffPayload = {
  __typename?: 'DeleteTimeOffPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** List of errors, if any */
  errors: Array<Scalars['String']['output']>;
  /** Whether the deletion was successful */
  success: Scalars['Boolean']['output'];
};

/** Education and degree information */
export type Education = {
  __typename?: 'Education';
  /** Degree name (e.g., 'Master of Science in Clinical Psychology') */
  degree: Scalars['String']['output'];
  /** Educational institution name */
  institution: Scalars['String']['output'];
  /** Year degree was obtained */
  year: Maybe<Scalars['Int']['output']>;
};

/** A field-level validation error */
export type FieldError = {
  __typename?: 'FieldError';
  /** The field name that has the error */
  field: Scalars['String']['output'];
  /** The error message */
  message: Scalars['String']['output'];
};

/** Financial assistance program information */
export type FinancialAssistance = {
  __typename?: 'FinancialAssistance';
  /** Additional program information and details */
  additionalInfo: Maybe<Array<Scalars['String']['output']>>;
  /** URL for hardship consideration application */
  applicationUrl: Scalars['String']['output'];
  /** Whether financial assistance program is available */
  available: Scalars['Boolean']['output'];
  /** Program description and information */
  description: Scalars['String']['output'];
  /** Range of available discounts (e.g., '20-75%') */
  discountRange: Scalars['String']['output'];
  /** List of eligibility requirements */
  eligibilityCriteria: Array<Scalars['String']['output']>;
  /** Whether sliding scale discounts are available */
  slidingScaleAvailable: Scalars['Boolean']['output'];
};

/** Insurance information */
export type Insurance = {
  __typename?: 'Insurance';
  /** Whether verification can be retried (Story 4.5) */
  canRetry: Scalars['Boolean']['output'];
  /** Whether verification can be retried */
  canRetryVerification: Scalars['Boolean']['output'];
  /** Presigned URL for back card image (15-min expiry) */
  cardImageBackUrl: Maybe<Scalars['String']['output']>;
  /** Presigned URL for front card image (15-min expiry) */
  cardImageFrontUrl: Maybe<Scalars['String']['output']>;
  /** Coinsurance percentage (0-100) */
  coinsurancePercentage: Maybe<Scalars['Int']['output']>;
  /** Copay amount for mental health services (USD) */
  copayAmount: Maybe<Scalars['Float']['output']>;
  /** Estimated cost breakdown for therapy session (only available if verified) */
  costEstimate: Maybe<CostEstimate>;
  /** Coverage information for verified insurance */
  coverageDetails: Maybe<CoverageDetails>;
  /** Coverage effective date */
  coverageEffectiveDate: Maybe<Scalars['ISO8601Date']['output']>;
  /** Coverage termination date */
  coverageTerminationDate: Maybe<Scalars['ISO8601Date']['output']>;
  /** When record was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Deductible amount (USD) */
  deductibleAmount: Maybe<Scalars['Float']['output']>;
  /** Deductible amount already met (USD) */
  deductibleMet: Maybe<Scalars['Float']['output']>;
  /** Whether member is eligible for coverage */
  eligible: Maybe<Scalars['Boolean']['output']>;
  /** Verification error category if failed */
  errorCategory: Maybe<Scalars['String']['output']>;
  /** Verification error message if failed */
  errorMessage: Maybe<Scalars['String']['output']>;
  /** Group number (encrypted) */
  groupNumber: Maybe<Scalars['String']['output']>;
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Member ID (encrypted) */
  memberId: Maybe<Scalars['String']['output']>;
  /** Whether mental health services are specifically covered */
  mentalHealthCovered: Maybe<Scalars['Boolean']['output']>;
  /** Whether OCR extraction needs manual review */
  needsReview: Scalars['Boolean']['output'];
  /** Array of action items for parent */
  nextSteps: Array<Scalars['String']['output']>;
  /** Confidence scores for extracted fields */
  ocrConfidence: Maybe<Scalars['JSON']['output']>;
  /** Whether OCR data is available for pre-population */
  ocrDataAvailable: Scalars['Boolean']['output'];
  /** OCR processing error if any */
  ocrError: Maybe<Scalars['JSON']['output']>;
  /** OCR-extracted field values */
  ocrExtracted: Maybe<Scalars['JSON']['output']>;
  /** Fields with low confidence that need review */
  ocrLowConfidenceFields: Maybe<Array<Scalars['String']['output']>>;
  /** Whether OCR processing has completed */
  ocrProcessed: Scalars['Boolean']['output'];
  /** Insurance payer/company name */
  payerName: Maybe<Scalars['String']['output']>;
  /** Policy number (encrypted) */
  policyNumber: Maybe<Scalars['String']['output']>;
  /** Number of retry attempts made */
  retryAttempts: Scalars['Int']['output'];
  /** Always available self-pay alternative */
  selfPayOption: SelfPayOption;
  /** Subscriber date of birth (encrypted) */
  subscriberDob: Maybe<Scalars['String']['output']>;
  /** Name on insurance policy (encrypted) */
  subscriberName: Maybe<Scalars['String']['output']>;
  /** Support contact for complex issues */
  supportContact: Maybe<SupportContact>;
  /** When record was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
  /** Plain language explanation of status */
  verificationMessage: Maybe<Scalars['String']['output']>;
  /** Verification result details */
  verificationResult: Maybe<Scalars['JSON']['output']>;
  /** Status of insurance verification */
  verificationStatus: Scalars['String']['output'];
  /** User-friendly status: Verified, Needs Attention, Unable to Verify */
  verificationStatusDisplay: Maybe<Scalars['String']['output']>;
  /** When eligibility was verified */
  verifiedAt: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** Detailed explanation of why this status occurred */
  whyExplanation: Maybe<Scalars['String']['output']>;
};


/** Insurance information */
export type InsuranceCostEstimateArgs = {
  serviceType?: InputMaybe<Scalars['String']['input']>;
};

/** Insurance-based cost estimate */
export type InsuranceEstimate = {
  __typename?: 'InsuranceEstimate';
  /** Important assumptions and disclaimers */
  assumptionNotes: Array<Scalars['String']['output']>;
  /** Explanation of the estimate */
  explanation: Scalars['String']['output'];
  /** Estimated cost per session */
  perSessionCost: Scalars['String']['output'];
  /** Total estimated cost for typical treatment */
  totalEstimatedCost: Scalars['String']['output'];
};

/** Insurance panel information for a therapist */
export type InsurancePanel = {
  __typename?: 'InsurancePanel';
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Insurance payer name */
  insuranceName: Scalars['String']['output'];
  /** State for this insurance panel */
  insuranceState: Maybe<Scalars['String']['output']>;
  /** Line of business (Commercial, Medicaid, etc.) */
  lineOfBusiness: Maybe<Scalars['String']['output']>;
  /** Network status (in_network or out_of_network) */
  networkStatus: Scalars['String']['output'];
};

/** Autogenerated return type of InsuranceStatusChanged. */
export type InsuranceStatusChangedPayload = {
  __typename?: 'InsuranceStatusChangedPayload';
  /** The updated insurance record */
  insurance: Insurance;
  /** Progress updates during eligibility verification */
  progress: Maybe<VerificationProgress>;
};

/** PHI-safe onboarding context for Intercom support agents */
export type IntercomContext = {
  __typename?: 'IntercomContext';
  /** Deep link to admin dashboard session view */
  adminLink: Scalars['String']['output'];
  /** Child age in years (calculated, not DOB, PHI-safe) */
  childAge: Maybe<Scalars['Int']['output']>;
  /** Error category if has_errors is true (session_expired, ocr_failed, etc.) */
  errorType: Maybe<Scalars['String']['output']>;
  /** Whether session has errors or blockers */
  hasErrors: Scalars['Boolean']['output'];
  /** Insurance verification status enum (pending, verified, failed, self_pay) */
  insuranceStatus: Maybe<Scalars['String']['output']>;
  /** Current onboarding status (started, in_progress, insurance_pending, etc.) */
  onboardingPhase: Scalars['String']['output'];
  /** Parent first name only (no last name, PHI-safe) */
  parentFirstName: Maybe<Scalars['String']['output']>;
  /** Onboarding session CUID identifier */
  sessionId: Scalars['String']['output'];
};

/** Intercom identity verification data for secure widget initialization */
export type IntercomIdentity = {
  __typename?: 'IntercomIdentity';
  /** Intercom workspace app ID (public, null if not configured) */
  appId: Maybe<Scalars['String']['output']>;
  /** Whether Intercom integration is enabled */
  enabled: Scalars['Boolean']['output'];
  /** Session ID used as Intercom user identifier (HIPAA: session ID ONLY, no PHI) */
  userId: Scalars['String']['output'];
  /** Signed JWT token for identity verification (null if disabled) */
  userJwt: Maybe<Scalars['String']['output']>;
};

/** A reason explaining why a therapist was matched */
export type MatchReason = {
  __typename?: 'MatchReason';
  /** Optional icon identifier for UI display */
  icon: Maybe<Scalars['String']['output']>;
  /** Reason identifier (e.g., 'specialty_match', 'availability') */
  id: Scalars['String']['output'];
  /** Human-readable reason text */
  text: Scalars['String']['output'];
};

/** Breakdown of match score components for transparency */
export type MatchScoreBreakdown = {
  __typename?: 'MatchScoreBreakdown';
  /** Age range fit score (0-100) - weighted 30% */
  ageRangeScore: Scalars['Int']['output'];
  /** Availability score (0-100) - weighted 20% */
  availabilityScore: Scalars['Int']['output'];
  /** Treatment modality score (0-100) - weighted 10% */
  modalityScore: Scalars['Int']['output'];
  /** Specialization match score (0-100) - weighted 40% */
  specializationScore: Scalars['Int']['output'];
};

/** A therapist with match-specific data for display */
export type MatchedTherapist = {
  __typename?: 'MatchedTherapist';
  /** Availability status (available, limited, unavailable) */
  availabilityStatus: Scalars['String']['output'];
  /** Human-readable availability text (e.g., 'Available this week') */
  availabilityText: Scalars['String']['output'];
  /** Brief bio or description */
  bio: Maybe<Scalars['String']['output']>;
  /** Professional credentials (e.g., 'LMFT', 'PhD', 'LCSW') */
  credentials: Scalars['String']['output'];
  /** Therapist unique identifier */
  id: Scalars['ID']['output'];
  /** Whether this is the best match (top recommendation) */
  isBestMatch: Scalars['Boolean']['output'];
  /** Reasons why this therapist was matched */
  matchReasons: Array<MatchReason>;
  /** Match quality score (0-100, higher is better) */
  matchScore: Scalars['Int']['output'];
  /** Full name of the therapist */
  name: Scalars['String']['output'];
  /** Professional photo URL */
  photoUrl: Maybe<Scalars['String']['output']>;
  /** Specialty areas (e.g., 'Anxiety', 'Teen Issues', 'ADHD') */
  specialties: Array<Scalars['String']['output']>;
  /** Years of professional experience */
  yearsOfExperience: Maybe<Scalars['Int']['output']>;
};

/** Chat message in assessment conversation */
export type Message = {
  __typename?: 'Message';
  /** Message content (encrypted) */
  content: Scalars['String']['output'];
  /** When message was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Additional message metadata */
  metadata: Maybe<Scalars['JSON']['output']>;
  /** Message sender role (user, assistant, system) */
  role: Scalars['String']['output'];
};

/** Autogenerated return type of MessageReceived. */
export type MessageReceivedPayload = {
  __typename?: 'MessageReceivedPayload';
  /** Message content */
  content: Scalars['String']['output'];
  /** When message was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Message ID */
  id: Scalars['ID']['output'];
  /** Additional message metadata */
  metadata: Maybe<Scalars['JSON']['output']>;
  /** Message role (user, assistant, system) */
  role: Scalars['String']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /**
   * Abandon an onboarding session explicitly.
   *
   * The session status will be set to ABANDONED and the session can no longer
   * be resumed or updated. All session data is retained per the data retention
   * policy (90 days, same as expired sessions).
   *
   * **Authorization:** Requires valid session token. Users can only abandon
   * their own sessions.
   *
   * **Client-side confirmation:** Clients should display a confirmation dialog
   * before calling this mutation. Recommended message:
   *
   * "Are you sure you want to abandon this session? Your progress will be saved,
   * but you won't be able to resume this session. You can start a new session
   * at any time."
   *
   * **Idempotency:** Calling this mutation on an already abandoned session
   * will succeed without error.
   */
  abandonSession: Maybe<AbandonSessionPayload>;
  /** Book an appointment with a therapist */
  bookAppointment: Maybe<BookAppointmentPayload>;
  /** Cancel an appointment */
  cancelAppointment: Maybe<CancelAppointmentPayload>;
  /** Validate prerequisites and transition session to assessment_complete status */
  completeAssessment: Maybe<CompleteAssessmentPayload>;
  /** Create a recurring availability slot for a therapist (admin only) */
  createAvailability: Maybe<CreateAvailabilityPayload>;
  /** Create a new anonymous onboarding session */
  createSession: Maybe<CreateSessionPayload>;
  /** Create a new therapist profile (admin only) */
  createTherapist: Maybe<CreateTherapistPayload>;
  /** Create a time-off period for a therapist (admin only) */
  createTimeOff: Maybe<CreateTimeOffPayload>;
  /** Delete an availability slot (admin only) */
  deleteAvailability: Maybe<DeleteAvailabilityPayload>;
  /** Soft delete a therapist by setting active=false (admin only) */
  deleteTherapist: Maybe<DeleteTherapistPayload>;
  /** Delete a time-off period (admin only) */
  deleteTimeOff: Maybe<DeleteTimeOffPayload>;
  /** Refresh access token using a valid refresh token. Implements token rotation for security. */
  refreshToken: Maybe<RefreshTokenPayload>;
  /**
   * Request to speak with a human during the onboarding process.
   *
   * This mutation flags the session for human follow-up and notifies the care team.
   * The parent can optionally provide a reason for the escalation request.
   *
   * The onboarding conversation can continue with AI assistance while waiting
   * for human contact, and all collected data is preserved.
   *
   * **Authorization:** Requires valid session token. Users can only request
   * human contact for their own sessions.
   *
   * **Idempotency:** Calling this mutation on an already escalated session
   * will succeed without duplicate notifications.
   */
  requestHumanContact: Maybe<RequestHumanContactPayload>;
  /** Request session recovery via email magic link */
  requestSessionRecovery: Maybe<RequestRecoveryPayload>;
  /** Reschedule an appointment to a new time */
  rescheduleAppointment: Maybe<RescheduleAppointmentPayload>;
  /** Save payment plan selection for billing integration (no payment processing) */
  savePaymentPlanSelection: Maybe<SavePaymentPlanSelectionPayload>;
  /** Select self-pay option for a session */
  selectSelfPay: Maybe<SelectSelfPayPayload>;
  /** Record parent's therapist selection for analytics */
  selectTherapist: Maybe<SelectTherapistPayload>;
  /** Send a message in the conversational intake */
  sendMessage: Maybe<SendMessagePayload>;
  /** Submit a response to a screening assessment question */
  submitAssessmentResponse: Maybe<SubmitResponsePayload>;
  /** Submit child information during intake */
  submitChildInfo: Maybe<SubmitChildInfoPayload>;
  /** Submit or update insurance information manually */
  submitInsuranceInfo: Maybe<SubmitInfoPayload>;
  /** Submit parent/guardian information during intake */
  submitParentInfo: Maybe<SubmitParentInfoPayload>;
  /** Submit patient availability time blocks for scheduling */
  submitPatientAvailability: Maybe<SubmitPatientAvailabilityPayload>;
  /** Switch from self-pay back to insurance verification */
  switchToInsurance: Maybe<SwitchToInsurancePayload>;
  /** Update an existing availability slot (admin only) */
  updateAvailability: Maybe<UpdateAvailabilityPayload>;
  /** Manually override deductible and OOP tracking data with audit trail */
  updateDeductibleOverride: Maybe<UpdateDeductibleOverridePayload>;
  /** Update session progress and extend expiration */
  updateSessionProgress: Maybe<UpdateSessionProgressPayload>;
  /** Update an existing therapist profile (admin only) */
  updateTherapist: Maybe<UpdateTherapistPayload>;
  /** Upload insurance card images (front and optional back) */
  uploadInsuranceCard: Maybe<UploadCardPayload>;
  /** Initiate insurance eligibility verification */
  verifyEligibility: Maybe<VerifyEligibilityPayload>;
};


export type MutationAbandonSessionArgs = {
  input: AbandonSessionInput;
};


export type MutationBookAppointmentArgs = {
  input: BookAppointmentInput;
};


export type MutationCancelAppointmentArgs = {
  input: CancelAppointmentInput;
};


export type MutationCompleteAssessmentArgs = {
  input: CompleteAssessmentInput;
};


export type MutationCreateAvailabilityArgs = {
  input: CreateAvailabilityInput;
};


export type MutationCreateSessionArgs = {
  deviceFingerprint?: InputMaybe<Scalars['String']['input']>;
  referralSource?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCreateTherapistArgs = {
  input: CreateTherapistInput;
};


export type MutationCreateTimeOffArgs = {
  input: CreateTimeOffInput;
};


export type MutationDeleteAvailabilityArgs = {
  input: DeleteAvailabilityInput;
};


export type MutationDeleteTherapistArgs = {
  input: DeleteTherapistInput;
};


export type MutationDeleteTimeOffArgs = {
  input: DeleteTimeOffInput;
};


export type MutationRefreshTokenArgs = {
  deviceFingerprint?: InputMaybe<Scalars['String']['input']>;
  refreshToken: Scalars['String']['input'];
};


export type MutationRequestHumanContactArgs = {
  input: RequestHumanContactInput;
};


export type MutationRequestSessionRecoveryArgs = {
  input: RequestRecoveryInput;
};


export type MutationRescheduleAppointmentArgs = {
  input: RescheduleAppointmentInput;
};


export type MutationSavePaymentPlanSelectionArgs = {
  input: SavePaymentPlanSelectionInput;
};


export type MutationSelectSelfPayArgs = {
  input: SelectSelfPayInput;
};


export type MutationSelectTherapistArgs = {
  input: SelectTherapistInput;
};


export type MutationSendMessageArgs = {
  content: Scalars['String']['input'];
  sessionId: Scalars['ID']['input'];
};


export type MutationSubmitAssessmentResponseArgs = {
  questionId: Scalars['String']['input'];
  responseText: Scalars['String']['input'];
  responseValue?: InputMaybe<Scalars['Int']['input']>;
  sessionId: Scalars['ID']['input'];
};


export type MutationSubmitChildInfoArgs = {
  child_info: ChildInput;
  session_id: Scalars['ID']['input'];
};


export type MutationSubmitInsuranceInfoArgs = {
  groupNumber?: InputMaybe<Scalars['String']['input']>;
  memberId?: InputMaybe<Scalars['String']['input']>;
  payerName?: InputMaybe<Scalars['String']['input']>;
  sessionId: Scalars['ID']['input'];
  subscriberDob?: InputMaybe<Scalars['String']['input']>;
  subscriberName?: InputMaybe<Scalars['String']['input']>;
};


export type MutationSubmitParentInfoArgs = {
  parentInfo: ParentInput;
  sessionId: Scalars['ID']['input'];
};


export type MutationSubmitPatientAvailabilityArgs = {
  input: SubmitPatientAvailabilityInput;
};


export type MutationSwitchToInsuranceArgs = {
  input: SwitchToInsuranceInput;
};


export type MutationUpdateAvailabilityArgs = {
  input: UpdateAvailabilityInput;
};


export type MutationUpdateDeductibleOverrideArgs = {
  input: UpdateDeductibleOverrideInput;
};


export type MutationUpdateSessionProgressArgs = {
  input: UpdateSessionProgressInput;
};


export type MutationUpdateTherapistArgs = {
  input: UpdateTherapistInput;
};


export type MutationUploadInsuranceCardArgs = {
  backImage?: InputMaybe<Scalars['Upload']['input']>;
  frontImage: Scalars['Upload']['input'];
  sessionId: Scalars['ID']['input'];
};


export type MutationVerifyEligibilityArgs = {
  insuranceId: Scalars['ID']['input'];
};

/** An onboarding session for parent intake */
export type OnboardingSession = {
  __typename?: 'OnboardingSession';
  /** Booked appointment (if any) */
  appointment: Maybe<Appointment>;
  /** Assessment data */
  assessment: Maybe<Assessment>;
  /** Child information */
  child: Maybe<Child>;
  /** Stored cost calculation breakdown for this session */
  costEstimate: Maybe<CostBreakdown>;
  /** When session was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Current payment method: "insurance" or "self_pay" */
  currentPaymentMethod: Scalars['String']['output'];
  /** When escalation was requested */
  escalationRequestedAt: Maybe<Scalars['ISO8601DateTime']['output']>;
  /** When session will expire */
  expiresAt: Scalars['ISO8601DateTime']['output'];
  /** Unique session identifier (CUID format with sess_ prefix) */
  id: Scalars['ID']['output'];
  /** Insurance information */
  insurance: Maybe<Insurance>;
  /** Chat messages in assessment conversation */
  messages: Maybe<Array<Message>>;
  /** Whether parent has requested to speak with a human */
  needsHumanContact: Scalars['Boolean']['output'];
  /** Parent/guardian information */
  parent: Maybe<Parent>;
  /** Selected payment plan (if any) */
  paymentPlan: Maybe<PaymentPlan>;
  /** Calculated progress indicators */
  progress: Progress;
  /** Session progress data */
  progressData: Scalars['JSON']['output'];
  /** How the parent found Daybreak */
  referralSource: Maybe<Scalars['String']['output']>;
  /** Current session status */
  status: Scalars['String']['output'];
  /** When session was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Package pricing option with savings */
export type PackageOption = {
  __typename?: 'PackageOption';
  /** Package description */
  description: Scalars['String']['output'];
  /** Cost per session in package */
  perSessionCost: Scalars['String']['output'];
  /** Amount saved compared to individual sessions */
  savings: Scalars['String']['output'];
  /** Number of sessions in package */
  sessions: Scalars['Int']['output'];
  /** Total package price */
  totalPrice: Scalars['String']['output'];
};

/** Parent or guardian information */
export type Parent = {
  __typename?: 'Parent';
  /** When record was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Parent email address (encrypted) */
  email: Scalars['String']['output'];
  /** Parent first name (encrypted) */
  firstName: Scalars['String']['output'];
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Whether parent is legal guardian */
  isGuardian: Scalars['Boolean']['output'];
  /** Parent last name (encrypted) */
  lastName: Scalars['String']['output'];
  /** Parent phone number (encrypted) */
  phone: Scalars['String']['output'];
  /** Relationship to child (parent, guardian, etc.) */
  relationship: Scalars['String']['output'];
  /** When record was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Input for submitting parent/guardian information */
export type ParentInput = {
  /** Parent's email address (RFC 5322 format) */
  email: Scalars['String']['input'];
  /** Parent's first name */
  firstName: Scalars['String']['input'];
  /** Whether this person is the legal guardian */
  isGuardian: Scalars['Boolean']['input'];
  /** Parent's last name */
  lastName: Scalars['String']['input'];
  /** Parent's phone number (E.164 format, e.g., +15551234567) */
  phone: Scalars['String']['input'];
  /** Relationship to child: parent, guardian, grandparent, foster_parent, or other */
  relationship: Scalars['String']['input'];
};

/** A patient's availability time block for scheduling */
export type PatientAvailability = {
  __typename?: 'PatientAvailability';
  /** When this was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Human-readable day name (e.g., 'Monday') */
  dayName: Scalars['String']['output'];
  /** Day of week (0=Sunday, 6=Saturday) */
  dayOfWeek: Scalars['Int']['output'];
  /** Duration in minutes */
  durationMinutes: Scalars['Int']['output'];
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** ID of the onboarding session */
  onboardingSessionId: Scalars['ID']['output'];
  /** Start time (HH:MM format) */
  startTime: Scalars['String']['output'];
  /** IANA timezone (e.g., America/Los_Angeles) */
  timezone: Scalars['String']['output'];
};

/** Input for a single patient availability time block */
export type PatientAvailabilityInput = {
  /** Day of week (0=Sunday, 1=Monday, ..., 6=Saturday) */
  day_of_week: Scalars['Int']['input'];
  /** Duration in minutes (default: 60) */
  duration_minutes?: InputMaybe<Scalars['Int']['input']>;
  /** Start time in HH:MM format (e.g., '09:00') */
  start_time: Scalars['String']['input'];
};

/** Payment method options for therapy services */
export type PaymentMethodEnum =
  /** Direct bank account transfer (ACH) */
  | 'BANK_TRANSFER'
  /** Credit or debit card (Visa, Mastercard, Amex, Discover) */
  | 'CARD'
  /** Health Savings Account or Flexible Spending Account */
  | 'HSA_FSA';

/** Payment plan selection for billing integration */
export type PaymentPlan = {
  __typename?: 'PaymentPlan';
  /** When the plan was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Human-readable plan description */
  description: Scalars['String']['output'];
  /** Discount amount applied in USD */
  discountApplied: Scalars['Float']['output'];
  /** Payment plan ID */
  id: Scalars['ID']['output'];
  /** Monthly payment amount in USD */
  monthlyAmount: Scalars['Float']['output'];
  /** Preferred payment method */
  paymentMethodPreference: PaymentMethodEnum;
  /** Plan duration in months (0 for upfront) */
  planDurationMonths: Scalars['Int']['output'];
  /** Payment plan status (pending, active, completed, cancelled) */
  status: Scalars['String']['output'];
  /** Total cost in USD */
  totalAmount: Scalars['Float']['output'];
  /** When the plan was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Payment plan option with cost breakdown */
export type PaymentPlanOption = {
  __typename?: 'PaymentPlanOption';
  /** Human-readable plan description */
  description: Scalars['String']['output'];
  /** Plan duration in months (0 for upfront payment) */
  durationMonths: Scalars['Int']['output'];
  /** Total fees/interest amount in USD */
  feeAmount: Scalars['Float']['output'];
  /** Whether this plan has interest or service fees */
  hasFees: Scalars['Boolean']['output'];
  /** Annual interest rate as percentage (e.g., 5.0 for 5%) */
  interestRate: Scalars['Float']['output'];
  /** Monthly payment amount in USD */
  monthlyAmount: Scalars['Float']['output'];
  /** Total cost including any interest/fees in USD */
  totalAmount: Scalars['Float']['output'];
  /** Discount percentage for upfront payment (null for monthly plans) */
  upfrontDiscount: Maybe<Scalars['Float']['output']>;
};

/** Progress indicators for onboarding session */
export type Progress = {
  __typename?: 'Progress';
  /** Array of completed phase names */
  completedPhases: Array<Scalars['String']['output']>;
  /** Current phase in the onboarding flow */
  currentPhase: Scalars['String']['output'];
  /** Estimated minutes to complete remaining phases (adaptive) */
  estimatedMinutesRemaining: Scalars['Int']['output'];
  /** Next phase in the sequence (null if at end) */
  nextPhase: Maybe<Scalars['String']['output']>;
  /** Progress percentage (0-100) based on completed required fields */
  percentage: Scalars['Int']['output'];
};

/** Autogenerated return type of ProgressUpdated. */
export type ProgressUpdatedPayload = {
  __typename?: 'ProgressUpdatedPayload';
  /** Array of completed phase names */
  completedPhases: Array<Scalars['String']['output']>;
  /** Current phase in onboarding flow */
  currentPhase: Scalars['String']['output'];
  /** Estimated minutes remaining */
  estimatedMinutesRemaining: Scalars['Int']['output'];
  /** Next phase in sequence (null if at end) */
  nextPhase: Maybe<Scalars['String']['output']>;
  /** Progress percentage (0-100) */
  percentage: Scalars['Int']['output'];
};

export type Query = {
  __typename?: 'Query';
  /** Get assessment for a session */
  assessment: Maybe<Assessment>;
  /** Get all assessment questions for a child's age */
  assessmentQuestions: Array<AssessmentQuestion>;
  /** Get available appointment slots for a therapist within a date range */
  availableSlots: Array<TimeSlot>;
  /** Calculate therapy session cost with detailed breakdown */
  calculateCost: CostBreakdown;
  /** Get support contact options for requesting human assistance */
  contactOptions: ContactOptions;
  /** Get cost comparison between insurance and self-pay for a session */
  costComparison: CostComparison;
  deductibleStatus: Maybe<DeductibleStatus>;
  /** Get financial assistance program information */
  financialAssistanceInfo: FinancialAssistance;
  /** Generate PHI-safe onboarding context for Intercom support agents */
  generateIntercomContext: IntercomContext;
  insuranceCostEstimate: Maybe<CostEstimate>;
  /** Get Intercom identity verification data for secure widget initialization */
  intercomIdentity: IntercomIdentity;
  /** Get matched therapists for a session (frontend-friendly format) */
  matchedTherapists: Maybe<TherapistMatchResultsWrapper>;
  /** Get patient availability time blocks for a session */
  patientAvailability: Array<PatientAvailability>;
  /** Get payment plan options for estimated cost */
  paymentPlanOptions: Array<PaymentPlanOption>;
  /** Get session by ID */
  session: OnboardingSession;
  /** Recover session using magic link token */
  sessionByRecoveryToken: SessionRecoveryPayload;
  /** Get AI-generated quick reply suggestions based on conversation context */
  suggestedReplies: Array<QuickReplyOption>;
  /** Get support request analytics (admin only) */
  supportAnalytics: SupportAnalytics;
  /** Get support requests for a session */
  supportRequests: Array<SupportRequest>;
  /** Get a single therapist by ID */
  therapist: Maybe<Therapist>;
  /** Get therapist availability grouped by date for scheduling calendar */
  therapistAvailability: TherapistAvailabilityResult;
  /** Get AI-matched therapist recommendations for a session */
  therapistMatches: Array<TherapistMatchResult>;
  /** Get detailed therapist profile with match-specific data */
  therapistProfile: Maybe<TherapistProfile>;
  /** List therapists with optional filters */
  therapists: Array<Therapist>;
};


export type QueryAssessmentArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryAssessmentQuestionsArgs = {
  childAge: Scalars['Int']['input'];
  instrument?: InputMaybe<Scalars['String']['input']>;
};


export type QueryAvailableSlotsArgs = {
  endDate: Scalars['ISO8601Date']['input'];
  startDate: Scalars['ISO8601Date']['input'];
  therapistId: Scalars['ID']['input'];
  timezone?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCalculateCostArgs = {
  discountCode?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  serviceType: Scalars['String']['input'];
  sessionId: Scalars['ID']['input'];
  specialServices?: InputMaybe<Array<Scalars['String']['input']>>;
  therapistTier?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCostComparisonArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryDeductibleStatusArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryGenerateIntercomContextArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryInsuranceCostEstimateArgs = {
  serviceType?: InputMaybe<Scalars['String']['input']>;
  sessionId: Scalars['ID']['input'];
};


export type QueryIntercomIdentityArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryMatchedTherapistsArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryPatientAvailabilityArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryPaymentPlanOptionsArgs = {
  estimatedCost: Scalars['Float']['input'];
  sessionId: Scalars['ID']['input'];
};


export type QuerySessionArgs = {
  id: Scalars['ID']['input'];
};


export type QuerySessionByRecoveryTokenArgs = {
  recoveryToken: Scalars['String']['input'];
};


export type QuerySuggestedRepliesArgs = {
  messageId?: InputMaybe<Scalars['ID']['input']>;
  sessionId: Scalars['ID']['input'];
};


export type QuerySupportAnalyticsArgs = {
  endDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
  startDate?: InputMaybe<Scalars['ISO8601Date']['input']>;
};


export type QuerySupportRequestsArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryTherapistArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTherapistAvailabilityArgs = {
  endDate: Scalars['ISO8601DateTime']['input'];
  sessionId?: InputMaybe<Scalars['ID']['input']>;
  startDate: Scalars['ISO8601DateTime']['input'];
  therapistId: Scalars['ID']['input'];
  timezone?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTherapistMatchesArgs = {
  sessionId: Scalars['ID']['input'];
};


export type QueryTherapistProfileArgs = {
  sessionId: Scalars['ID']['input'];
  therapistId: Scalars['ID']['input'];
};


export type QueryTherapistsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  insuranceName?: InputMaybe<Scalars['String']['input']>;
  specialization?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
};

/** Quick reply suggestion option for chat interface */
export type QuickReplyOption = {
  __typename?: 'QuickReplyOption';
  /** Optional emoji or icon */
  icon: Maybe<Scalars['String']['output']>;
  /** Display text for the button */
  label: Scalars['String']['output'];
  /** Value sent when selected (usually same as label) */
  value: Scalars['String']['output'];
};

/** Autogenerated return type of RefreshToken. */
export type RefreshTokenPayload = {
  __typename?: 'RefreshTokenPayload';
  /** Error message if refresh failed */
  error: Maybe<Scalars['String']['output']>;
  /** Access token expiration in seconds */
  expiresIn: Maybe<Scalars['Int']['output']>;
  /** New refresh token (old one is invalidated) */
  refreshToken: Maybe<Scalars['String']['output']>;
  /** Whether the refresh was successful */
  success: Scalars['Boolean']['output'];
  /** New JWT access token */
  token: Maybe<Scalars['String']['output']>;
  /** Token type (Bearer) */
  tokenType: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RequestHumanContact */
export type RequestHumanContactInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Optional reason for requesting human assistance (PHI-encrypted) */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** The ID of the session requesting human contact */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of RequestHumanContact. */
export type RequestHumanContactPayload = {
  __typename?: 'RequestHumanContactPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** The session with escalation status updated */
  session: OnboardingSession;
  /** Indicates if the escalation request was successful */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of RequestRecovery */
export type RequestRecoveryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** ID of the session to recover */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of RequestRecovery. */
export type RequestRecoveryPayload = {
  __typename?: 'RequestRecoveryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Human-readable message */
  message: Scalars['String']['output'];
  /** Whether the request was successful */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of RescheduleAppointment */
export type RescheduleAppointmentInput = {
  /** Appointment ID to reschedule */
  appointmentId: Scalars['ID']['input'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** New appointment date and time */
  newScheduledAt: Scalars['ISO8601DateTime']['input'];
};

/** Autogenerated return type of RescheduleAppointment. */
export type RescheduleAppointmentPayload = {
  __typename?: 'RescheduleAppointmentPayload';
  /** New appointment */
  appointment: Maybe<Appointment>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Errors encountered during rescheduling */
  errors: Array<Scalars['String']['output']>;
  /** Whether rescheduling was successful */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of SavePaymentPlanSelection */
export type SavePaymentPlanSelectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Discount amount applied in USD (optional) */
  discountApplied?: InputMaybe<Scalars['Float']['input']>;
  /** Monthly payment amount in USD */
  monthlyAmount: Scalars['Float']['input'];
  /** Preferred payment method */
  paymentMethodPreference: PaymentMethodEnum;
  /** Selected plan duration in months (0 for upfront) */
  planDurationMonths: Scalars['Int']['input'];
  /** Session ID to link payment plan to */
  sessionId: Scalars['ID']['input'];
  /** Total cost in USD */
  totalAmount: Scalars['Float']['input'];
};

/** Autogenerated return type of SavePaymentPlanSelection. */
export type SavePaymentPlanSelectionPayload = {
  __typename?: 'SavePaymentPlanSelectionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Success or error message */
  message: Maybe<Scalars['String']['output']>;
  /** Created payment plan */
  paymentPlan: PaymentPlan;
  /** Whether the operation succeeded */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of SelectSelfPay */
export type SelectSelfPayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Session ID */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of SelectSelfPay. */
export type SelectSelfPayPayload = {
  __typename?: 'SelectSelfPayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  session: OnboardingSession;
  success: Scalars['Boolean']['output'];
};

/** Autogenerated input type of SelectTherapist */
export type SelectTherapistInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Onboarding session ID */
  sessionId: Scalars['ID']['input'];
  /** Selected therapist ID */
  therapistId: Scalars['ID']['input'];
};

/** Autogenerated return type of SelectTherapist. */
export type SelectTherapistPayload = {
  __typename?: 'SelectTherapistPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Any error messages */
  errors: Array<Scalars['String']['output']>;
  /** Whether selection was recorded successfully */
  success: Scalars['Boolean']['output'];
  /** Updated match record with selection */
  therapistMatch: Maybe<TherapistMatch>;
};

/** Self-pay cost estimate with transparent pricing */
export type SelfPayEstimate = {
  __typename?: 'SelfPayEstimate';
  /** Base rate per session (e.g., '$50 per session') */
  baseRate: Scalars['String']['output'];
  /** Package pricing options with savings */
  packageOptions: Array<PackageOption>;
  /** Information about sliding scale discounts if available */
  slidingScaleInfo: Maybe<Scalars['String']['output']>;
  /** Total cost for typical treatment (8-12 sessions) */
  totalForTypicalTreatment: Scalars['String']['output'];
  /** No hidden fees message */
  transparentPricingMessage: Scalars['String']['output'];
  /** Services included in the rate */
  whatIsIncluded: Array<Scalars['String']['output']>;
  /** Services not included in the rate */
  whatIsNotIncluded: Array<Scalars['String']['output']>;
};

/** Self-pay option preview (always available) */
export type SelfPayOption = {
  __typename?: 'SelfPayOption';
  /** Whether self-pay is available (always true) */
  available: Scalars['Boolean']['output'];
  /** Self-pay option description */
  description: Scalars['String']['output'];
  /** Preview of self-pay rates */
  previewRate: Maybe<Scalars['String']['output']>;
};

/** Autogenerated return type of SendMessage. */
export type SendMessagePayload = {
  __typename?: 'SendMessagePayload';
  /** Whether the assessment chat is complete and user can proceed */
  assessmentComplete: Scalars['Boolean']['output'];
  /** The AI assistant's response */
  assistantMessage: Maybe<Message>;
  /** Errors if mutation failed */
  errors: Array<Scalars['String']['output']>;
  /** The user's message */
  userMessage: Maybe<Message>;
};

/** Response from session recovery */
export type SessionRecoveryPayload = {
  __typename?: 'SessionRecoveryPayload';
  /** New refresh token for token renewal */
  refreshToken: Scalars['String']['output'];
  /** Recovered session with full progress */
  session: OnboardingSession;
  /** New JWT authentication token for this session */
  token: Scalars['String']['output'];
};

/** Autogenerated return type of SessionUpdated. */
export type SessionUpdatedPayload = {
  __typename?: 'SessionUpdatedPayload';
  /** The updated session */
  session: OnboardingSession;
};

/** Autogenerated return type of SubmitChildInfo. */
export type SubmitChildInfoPayload = {
  __typename?: 'SubmitChildInfoPayload';
  /** Created or updated child record */
  child: Maybe<Child>;
  /** List of validation errors */
  errors: Array<Scalars['String']['output']>;
  /** Updated session with progress */
  session: Maybe<OnboardingSession>;
};

/** Autogenerated return type of SubmitInfo. */
export type SubmitInfoPayload = {
  __typename?: 'SubmitInfoPayload';
  /** List of validation errors */
  errors: Array<FieldError>;
  /** Updated insurance record */
  insurance: Maybe<Insurance>;
  /** Whether fields were pre-populated from OCR data */
  prePopulatedFromOcr: Scalars['Boolean']['output'];
};

/** Autogenerated return type of SubmitParentInfo. */
export type SubmitParentInfoPayload = {
  __typename?: 'SubmitParentInfoPayload';
  /** List of validation errors */
  errors: Array<Scalars['String']['output']>;
  /** Created or updated parent record */
  parent: Maybe<Parent>;
};

/** Autogenerated input type of SubmitPatientAvailability */
export type SubmitPatientAvailabilityInput = {
  /** Array of availability time blocks */
  availabilities: Array<PatientAvailabilityInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** IANA timezone (e.g., America/Los_Angeles) */
  timezone: Scalars['String']['input'];
};

/** Autogenerated return type of SubmitPatientAvailability. */
export type SubmitPatientAvailabilityPayload = {
  __typename?: 'SubmitPatientAvailabilityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Error messages if any */
  errors: Array<Scalars['String']['output']>;
  /** The created availability blocks */
  patientAvailabilities: Maybe<Array<PatientAvailability>>;
  /** Whether the operation succeeded */
  success: Scalars['Boolean']['output'];
};

/** Autogenerated return type of SubmitResponse. */
export type SubmitResponsePayload = {
  __typename?: 'SubmitResponsePayload';
  /** Updated assessment */
  assessment: Maybe<Assessment>;
  /** Validation errors */
  errors: Array<Scalars['String']['output']>;
  /** Next question to ask */
  nextQuestion: Maybe<AssessmentQuestion>;
  /** Assessment progress */
  progress: Maybe<AssessmentProgress>;
};

export type Subscription = {
  __typename?: 'Subscription';
  /** Subscribe to assessment progress updates */
  assessmentUpdated: AssessmentUpdatedPayload;
  /** Subscribe to insurance status changes for a session */
  insuranceStatusChanged: InsuranceStatusChangedPayload;
  /** Subscribe to new messages in a conversation */
  messageReceived: MessageReceivedPayload;
  /** Subscribe to progress updates for a specific session */
  progressUpdated: ProgressUpdatedPayload;
  /** Subscribe to updates for a specific session */
  sessionUpdated: SessionUpdatedPayload;
};


export type SubscriptionAssessmentUpdatedArgs = {
  sessionId: Scalars['ID']['input'];
};


export type SubscriptionInsuranceStatusChangedArgs = {
  sessionId: Scalars['ID']['input'];
};


export type SubscriptionMessageReceivedArgs = {
  sessionId: Scalars['ID']['input'];
};


export type SubscriptionProgressUpdatedArgs = {
  sessionId: Scalars['ID']['input'];
};


export type SubscriptionSessionUpdatedArgs = {
  sessionId: Scalars['ID']['input'];
};

export type SupportAnalytics = {
  __typename?: 'SupportAnalytics';
  /** Average time to resolution in hours */
  averageResolutionTime: Maybe<Scalars['Float']['output']>;
  /** Support requests grouped by onboarding session status */
  requestsBySessionStatus: Scalars['JSON']['output'];
  /** Support requests grouped by source widget location */
  requestsBySource: Scalars['JSON']['output'];
  /** Percentage of resolved requests (0-100) */
  resolutionRate: Scalars['Float']['output'];
  /** Number of unique sessions that contacted support */
  sessionsWithSupport: Scalars['Int']['output'];
  /** Total number of support requests */
  totalRequests: Scalars['Int']['output'];
};

/** Support contact information for insurance issues */
export type SupportContact = {
  __typename?: 'SupportContact';
  /** Contact email address */
  email: Scalars['String']['output'];
  /** Availability hours */
  hours: Scalars['String']['output'];
  /** Contact phone number */
  phone: Scalars['String']['output'];
  /** Contact type: 'general' or 'specialist' */
  type: Scalars['String']['output'];
};

export type SupportRequest = {
  __typename?: 'SupportRequest';
  /** When the support request was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Support request ID */
  id: Scalars['ID']['output'];
  /** Intercom conversation ID */
  intercomConversationId: Maybe<Scalars['String']['output']>;
  /** Whether the support request has been resolved */
  resolved: Scalars['Boolean']['output'];
  /** Onboarding session ID */
  sessionId: Scalars['ID']['output'];
  /** Source widget location (e.g., welcome-screen, insurance-verification) */
  source: Scalars['String']['output'];
  /** When the support request was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of SwitchToInsurance */
export type SwitchToInsuranceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Session ID */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of SwitchToInsurance. */
export type SwitchToInsurancePayload = {
  __typename?: 'SwitchToInsurancePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  session: OnboardingSession;
  success: Scalars['Boolean']['output'];
};

/** Therapist profile information */
export type Therapist = {
  __typename?: 'Therapist';
  /** Whether therapist is active */
  active: Scalars['Boolean']['output'];
  /** Age ranges served (e.g., 5-12, 13-17) */
  ageRanges: Array<Scalars['String']['output']>;
  /** Default appointment duration in minutes */
  appointmentDurationMinutes: Scalars['Int']['output'];
  /** Weekly recurring availability slots */
  availabilities: Array<TherapistAvailability>;
  /** Therapist biography */
  bio: Maybe<Scalars['String']['output']>;
  /** Buffer time between appointments in minutes */
  bufferTimeMinutes: Scalars['Int']['output'];
  /** When record was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Therapist email address */
  email: Maybe<Scalars['String']['output']>;
  /** Therapist first name */
  firstName: Scalars['String']['output'];
  /** Full name (computed) */
  fullName: Scalars['String']['output'];
  /** Unique identifier */
  id: Scalars['ID']['output'];
  /** Insurance panels accepted */
  insurancePanels: Array<InsurancePanel>;
  /** Languages spoken (ISO 639-1 codes) */
  languages: Array<Scalars['String']['output']>;
  /** Therapist last name */
  lastName: Scalars['String']['output'];
  /** License expiration date */
  licenseExpiration: Maybe<Scalars['ISO8601Date']['output']>;
  /** License number */
  licenseNumber: Maybe<Scalars['String']['output']>;
  /** State where licensed */
  licenseState: Maybe<Scalars['String']['output']>;
  /** License type (LCSW, LMFT, LPCC, etc.) */
  licenseType: Maybe<Scalars['String']['output']>;
  /** National Provider Identifier */
  npiNumber: Maybe<Scalars['String']['output']>;
  /** Therapist phone number */
  phone: Maybe<Scalars['String']['output']>;
  /** Profile photo URL */
  photoUrl: Maybe<Scalars['String']['output']>;
  /** Clinical specializations */
  specializations: Array<Scalars['String']['output']>;
  /** Time-off periods (vacations, blocked times) */
  timeOffs: Array<TherapistTimeOff>;
  /** Treatment modalities (CBT, DBT, EMDR, etc.) */
  treatmentModalities: Array<Scalars['String']['output']>;
  /** When record was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** A recurring availability slot for a therapist */
export type TherapistAvailability = {
  __typename?: 'TherapistAvailability';
  /** When this availability was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Day of week (0=Sunday, 1=Monday, ..., 6=Saturday) */
  dayOfWeek: Scalars['Int']['output'];
  /** End time of availability (HH:MM:SS format) */
  endTime: Scalars['String']['output'];
  /** Unique identifier for the availability slot */
  id: Scalars['ID']['output'];
  /** Whether this is a recurring weekly availability */
  isRepeating: Scalars['Boolean']['output'];
  /** Start time of availability (HH:MM:SS format) */
  startTime: Scalars['String']['output'];
  /** ID of the therapist */
  therapistId: Scalars['ID']['output'];
  /** IANA timezone (e.g., America/Los_Angeles) */
  timezone: Scalars['String']['output'];
  /** When this availability was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Therapist availability results grouped by date */
export type TherapistAvailabilityResult = {
  __typename?: 'TherapistAvailabilityResult';
  /** List of dates with availability information */
  availableDates: Array<AvailableDate>;
  /** Therapist ID */
  therapistId: Scalars['ID']['output'];
  /** Therapist full name */
  therapistName: Scalars['String']['output'];
  /** Therapist photo URL */
  therapistPhotoUrl: Maybe<Scalars['String']['output']>;
  /** Timezone for the availability data */
  timezone: Scalars['String']['output'];
};

/** Input for creating or updating therapist profiles */
export type TherapistInput = {
  /** Whether therapist is active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Age ranges served (e.g., ['5-12', '13-17']) */
  age_ranges?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Therapist biography */
  bio?: InputMaybe<Scalars['String']['input']>;
  /** Therapist's email address */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Therapist's first name */
  first_name: Scalars['String']['input'];
  /** Languages spoken (ISO 639-1 codes) */
  languages?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Therapist's last name */
  last_name: Scalars['String']['input'];
  /** License expiration date */
  license_expiration?: InputMaybe<Scalars['ISO8601Date']['input']>;
  /** License number */
  license_number?: InputMaybe<Scalars['String']['input']>;
  /** State where licensed */
  license_state?: InputMaybe<Scalars['String']['input']>;
  /** License type (LCSW, LMFT, LPCC, etc.) */
  license_type?: InputMaybe<Scalars['String']['input']>;
  /** National Provider Identifier */
  npi_number?: InputMaybe<Scalars['String']['input']>;
  /** Therapist's phone number */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Profile photo URL */
  photo_url?: InputMaybe<Scalars['String']['input']>;
  /** Clinical specializations */
  specializations?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Treatment modalities (CBT, DBT, EMDR, etc.) */
  treatment_modalities?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** A therapist matching record for analytics */
export type TherapistMatch = {
  __typename?: 'TherapistMatch';
  /** When matching was performed */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** Criteria used for matching */
  criteriaUsed: Scalars['JSON']['output'];
  /** Match record ID */
  id: Scalars['ID']['output'];
  /** Array of matched therapist data with scores */
  matchedTherapists: Scalars['JSON']['output'];
  /** Session this match was performed for */
  onboardingSessionId: Scalars['ID']['output'];
  /** Time taken to perform matching (milliseconds) */
  processingTimeMs: Scalars['Int']['output'];
  /** Selected therapist profile */
  selectedTherapist: Maybe<Therapist>;
  /** ID of therapist selected by parent */
  selectedTherapistId: Maybe<Scalars['ID']['output']>;
};

/** A therapist match result with score, reasoning, and availability */
export type TherapistMatchResult = {
  __typename?: 'TherapistMatchResult';
  /** Next 3-5 available appointment slots (lazy-loaded) */
  availableSlots: Array<TimeSlot>;
  /** Parent-friendly explanation of why this therapist matches */
  reasoning: Scalars['String']['output'];
  /** Overall match score (0-100) */
  score: Scalars['Int']['output'];
  /** Breakdown of individual scoring components */
  scoreBreakdown: MatchScoreBreakdown;
  /** Matched therapist profile */
  therapist: Therapist;
};

/** Therapist matching results wrapper */
export type TherapistMatchResultsWrapper = {
  __typename?: 'TherapistMatchResultsWrapper';
  /** General explanation of matching criteria used */
  matchingCriteria: Maybe<Scalars['String']['output']>;
  /** List of matched therapists (2-3 typically) */
  therapists: Array<MatchedTherapist>;
  /** Total number of therapists matched */
  totalCount: Scalars['Int']['output'];
};

/** Detailed therapist profile with match-specific data */
export type TherapistProfile = {
  __typename?: 'TherapistProfile';
  /** Therapeutic approach description */
  approach: Maybe<Scalars['String']['output']>;
  /** Availability status (available, limited, unavailable) */
  availabilityStatus: Scalars['String']['output'];
  /** Human-readable availability text */
  availabilityText: Scalars['String']['output'];
  /** Next available appointment slots */
  availableSlots: Array<TimeSlot>;
  /** Detailed biography */
  bio: Maybe<Scalars['String']['output']>;
  /** Professional certifications */
  certifications: Array<Scalars['String']['output']>;
  /** Professional credentials (e.g., 'LMFT', 'PhD', 'LCSW') */
  credentials: Scalars['String']['output'];
  /** Education and degrees */
  education: Array<Education>;
  /** Therapist unique identifier */
  id: Scalars['ID']['output'];
  /** Languages spoken */
  languages: Array<Scalars['String']['output']>;
  /** Reasons why this therapist was matched (requires session_id) */
  matchReasons: Array<MatchReason>;
  /** Full name of the therapist */
  name: Scalars['String']['output'];
  /** Professional photo URL */
  photoUrl: Maybe<Scalars['String']['output']>;
  /** Specialty areas (e.g., 'Anxiety', 'Teen Issues', 'ADHD') */
  specialties: Array<Scalars['String']['output']>;
  /** Years of professional experience */
  yearsOfExperience: Maybe<Scalars['Int']['output']>;
};


/** Detailed therapist profile with match-specific data */
export type TherapistProfileAvailableSlotsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


/** Detailed therapist profile with match-specific data */
export type TherapistProfileMatchReasonsArgs = {
  sessionId: Scalars['ID']['input'];
};

/** A time-off period for a therapist (vacation, blocked time, etc.) */
export type TherapistTimeOff = {
  __typename?: 'TherapistTimeOff';
  /** When this time-off was created */
  createdAt: Scalars['ISO8601DateTime']['output'];
  /** End date of time-off period */
  endDate: Scalars['ISO8601Date']['output'];
  /** Unique identifier for the time-off period */
  id: Scalars['ID']['output'];
  /** Optional reason for time-off (e.g., vacation, conference) */
  reason: Maybe<Scalars['String']['output']>;
  /** Start date of time-off period */
  startDate: Scalars['ISO8601Date']['output'];
  /** ID of the therapist */
  therapistId: Scalars['ID']['output'];
  /** When this time-off was last updated */
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** A calculated available time slot (not backed by a database model) */
export type TimeSlot = {
  __typename?: 'TimeSlot';
  /** Duration of the slot in minutes (appointment + buffer) */
  durationMinutes: Scalars['Int']['output'];
  /** End time of the available slot */
  endTime: Scalars['ISO8601DateTime']['output'];
  /** Start time of the available slot */
  startTime: Scalars['ISO8601DateTime']['output'];
  /** ID of the therapist for this slot */
  therapistId: Scalars['ID']['output'];
};

/** Autogenerated input type of UpdateAvailability */
export type UpdateAvailabilityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Day of week (0=Sunday, 1=Monday, ..., 6=Saturday) */
  dayOfWeek?: InputMaybe<Scalars['Int']['input']>;
  /** End time (HH:MM format, e.g., 17:00) */
  endTime?: InputMaybe<Scalars['String']['input']>;
  /** ID of the availability slot to update */
  id: Scalars['ID']['input'];
  /** Whether this is a recurring weekly availability */
  isRepeating?: InputMaybe<Scalars['Boolean']['input']>;
  /** Start time (HH:MM format, e.g., 09:00) */
  startTime?: InputMaybe<Scalars['String']['input']>;
  /** IANA timezone (e.g., America/Los_Angeles) */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateAvailability. */
export type UpdateAvailabilityPayload = {
  __typename?: 'UpdateAvailabilityPayload';
  /** The updated availability slot */
  availability: Maybe<TherapistAvailability>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** List of validation errors, if any */
  errors: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateDeductibleOverride */
export type UpdateDeductibleOverrideInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Total deductible amount (optional - override total if provided) */
  deductibleAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Amount of deductible met (optional - keeps existing if not provided) */
  deductibleMet?: InputMaybe<Scalars['Float']['input']>;
  /** Total OOP max amount (optional - override total if provided) */
  oopMaxAmount?: InputMaybe<Scalars['Float']['input']>;
  /** Amount of OOP max met (optional - keeps existing if not provided) */
  oopMet?: InputMaybe<Scalars['Float']['input']>;
  /** Reason for manual override (required for audit trail) */
  overrideReason: Scalars['String']['input'];
  /** Onboarding session ID */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateDeductibleOverride. */
export type UpdateDeductibleOverridePayload = {
  __typename?: 'UpdateDeductibleOverridePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** List of errors if update failed */
  errors: Array<Scalars['String']['output']>;
  /** Updated insurance record */
  insurance: Maybe<Insurance>;
};

/** Autogenerated input type of UpdateSessionProgress */
export type UpdateSessionProgressInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Progress data to merge */
  progress: Scalars['JSON']['input'];
  /** The session ID */
  sessionId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateSessionProgress. */
export type UpdateSessionProgressPayload = {
  __typename?: 'UpdateSessionProgressPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  session: OnboardingSession;
};

/** Autogenerated input type of UpdateTherapist */
export type UpdateTherapistInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** Therapist ID */
  id: Scalars['ID']['input'];
  /** Updated therapist profile data */
  input: TherapistInput;
};

/** Autogenerated return type of UpdateTherapist. */
export type UpdateTherapistPayload = {
  __typename?: 'UpdateTherapistPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  /** Validation errors if any */
  errors: Array<Scalars['String']['output']>;
  /** Whether update was successful */
  success: Scalars['Boolean']['output'];
  /** Updated therapist */
  therapist: Maybe<Therapist>;
};

/** Autogenerated return type of UploadCard. */
export type UploadCardPayload = {
  __typename?: 'UploadCardPayload';
  /** List of validation errors */
  errors: Array<Scalars['String']['output']>;
  /** Updated insurance record with presigned URLs */
  insurance: Maybe<Insurance>;
};

/** Progress updates during eligibility verification */
export type VerificationProgress = {
  __typename?: 'VerificationProgress';
  /** User-friendly progress message */
  message: Scalars['String']['output'];
  /** Progress percentage (0, 33, 66, or 100) */
  percentage: Scalars['Int']['output'];
};

/** Autogenerated return type of VerifyEligibility. */
export type VerifyEligibilityPayload = {
  __typename?: 'VerifyEligibilityPayload';
  /** Whether result was returned from cache (within 24 hours) */
  cached: Scalars['Boolean']['output'];
  /** List of validation errors */
  errors: Array<FieldError>;
  /** The updated insurance record with verification status */
  insurance: Maybe<Insurance>;
};

export type GetCostEstimateQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type GetCostEstimateQuery = { __typename?: 'Query', costComparison: { __typename?: 'CostComparison', recommendation: string | null, savingsIfSelfPay: number | null, highlightSelfPay: boolean, insuranceEstimate: { __typename?: 'InsuranceEstimate', perSessionCost: string, totalEstimatedCost: string, explanation: string, assumptionNotes: Array<string> } | null, selfPayEstimate: { __typename?: 'SelfPayEstimate', baseRate: string, totalForTypicalTreatment: string, slidingScaleInfo: string | null, transparentPricingMessage: string, whatIsIncluded: Array<string>, whatIsNotIncluded: Array<string>, packageOptions: Array<{ __typename?: 'PackageOption', sessions: number, totalPrice: string, perSessionCost: string, savings: string, description: string }> }, comparisonTable: Array<{ __typename?: 'ComparisonRow', label: string, insuranceValue: string | null, selfPayValue: string, highlightSelfPay: boolean }> } };

export type GetEnhancedCostComparisonQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type GetEnhancedCostComparisonQuery = { __typename?: 'Query', costComparison: { __typename?: 'CostComparison', recommendation: string | null, savingsIfSelfPay: number | null, highlightSelfPay: boolean, insuranceEstimate: { __typename?: 'InsuranceEstimate', perSessionCost: string, totalEstimatedCost: string, explanation: string, assumptionNotes: Array<string> } | null, selfPayEstimate: { __typename?: 'SelfPayEstimate', baseRate: string, totalForTypicalTreatment: string, slidingScaleInfo: string | null, transparentPricingMessage: string, whatIsIncluded: Array<string>, whatIsNotIncluded: Array<string>, packageOptions: Array<{ __typename?: 'PackageOption', sessions: number, totalPrice: string, perSessionCost: string, savings: string, description: string }> }, comparisonTable: Array<{ __typename?: 'ComparisonRow', label: string, insuranceValue: string | null, selfPayValue: string, highlightSelfPay: boolean }> }, deductibleStatus: { __typename?: 'DeductibleStatus', amount: number, met: number, remaining: number, progressPercentage: number | null, isMet: boolean, oopMaxAmount: number | null, oopMet: number | null, oopRemaining: number | null, oopProgressPercentage: number | null } | null, session: { __typename?: 'OnboardingSession', insurance: { __typename?: 'Insurance', cardImageFrontUrl: string | null, cardImageBackUrl: string | null, payerName: string | null, memberId: string | null, copayAmount: number | null, coinsurancePercentage: number | null, deductibleAmount: number | null, deductibleMet: number | null } | null } };

export type GetPaymentPlansQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
  estimatedCost: Scalars['Float']['input'];
}>;


export type GetPaymentPlansQuery = { __typename?: 'Query', paymentPlanOptions: Array<{ __typename?: 'PaymentPlanOption', durationMonths: number, monthlyAmount: number, totalAmount: number, interestRate: number, hasFees: boolean, feeAmount: number, upfrontDiscount: number | null, description: string }>, financialAssistanceInfo: { __typename?: 'FinancialAssistance', available: boolean, eligibilityCriteria: Array<string>, applicationUrl: string, description: string, slidingScaleAvailable: boolean, discountRange: string, additionalInfo: Array<string> | null } };

export type SavePaymentPlanSelectionMutationVariables = Exact<{
  input: SavePaymentPlanSelectionInput;
}>;


export type SavePaymentPlanSelectionMutation = { __typename?: 'Mutation', savePaymentPlanSelection: { __typename?: 'SavePaymentPlanSelectionPayload', success: boolean, paymentPlan: { __typename?: 'PaymentPlan', id: string, planDurationMonths: number, monthlyAmount: number, totalAmount: number, discountApplied: number, paymentMethodPreference: PaymentMethodEnum, status: string, description: string } } | null };

export type GetMatchedTherapistsQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type GetMatchedTherapistsQuery = { __typename?: 'Query', matchedTherapists: { __typename?: 'TherapistMatchResultsWrapper', totalCount: number, matchingCriteria: string | null, therapists: Array<{ __typename?: 'MatchedTherapist', id: string, name: string, credentials: string, photoUrl: string | null, specialties: Array<string>, availabilityStatus: string, availabilityText: string, yearsOfExperience: number | null, bio: string | null, matchScore: number, isBestMatch: boolean, matchReasons: Array<{ __typename?: 'MatchReason', id: string, text: string, icon: string | null }> }> } | null };

export type GetTherapistProfileQueryVariables = Exact<{
  therapistId: Scalars['ID']['input'];
  sessionId: Scalars['ID']['input'];
}>;


export type GetTherapistProfileQuery = { __typename?: 'Query', therapistProfile: { __typename?: 'TherapistProfile', id: string, name: string, credentials: string, photoUrl: string | null, bio: string | null, specialties: Array<string>, yearsOfExperience: number | null, approach: string | null, languages: Array<string>, certifications: Array<string>, availabilityStatus: string, availabilityText: string, education: Array<{ __typename?: 'Education', degree: string, institution: string, year: number | null }>, matchReasons: Array<{ __typename?: 'MatchReason', id: string, text: string, icon: string | null }>, availableSlots: Array<{ __typename?: 'TimeSlot', startTime: any, endTime: any, therapistId: string, durationMinutes: number }> } | null };

export type BookAppointmentMutationVariables = Exact<{
  input: BookAppointmentInput;
}>;


export type BookAppointmentMutation = { __typename?: 'Mutation', bookAppointment: { __typename?: 'BookAppointmentPayload', success: boolean, errors: Array<string>, appointment: { __typename?: 'Appointment', id: string, onboardingSessionId: string, scheduledAt: any, durationMinutes: number, status: string, virtualLink: string | null, confirmationNumber: string, therapist: { __typename?: 'Therapist', id: string, fullName: string, licenseType: string | null, photoUrl: string | null } } | null } | null };

export type GetTherapistAvailabilityQueryVariables = Exact<{
  therapistId: Scalars['ID']['input'];
  startDate: Scalars['ISO8601DateTime']['input'];
  endDate: Scalars['ISO8601DateTime']['input'];
  timezone?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetTherapistAvailabilityQuery = { __typename?: 'Query', therapistAvailability: { __typename?: 'TherapistAvailabilityResult', therapistId: string, therapistName: string, therapistPhotoUrl: string | null, timezone: string, availableDates: Array<{ __typename?: 'AvailableDate', date: any, hasAvailability: boolean, slots: Array<{ __typename?: 'AvailableSlot', id: string, startTime: any, endTime: any, isAvailable: boolean, timezone: string }> }> } };

export type AbandonSessionMutationVariables = Exact<{
  input: AbandonSessionInput;
}>;


export type AbandonSessionMutation = { __typename?: 'Mutation', abandonSession: { __typename?: 'AbandonSessionPayload', success: boolean, session: { __typename?: 'OnboardingSession', id: string, status: string } } | null };

export type CompleteAssessmentMutationVariables = Exact<{
  input: CompleteAssessmentInput;
}>;


export type CompleteAssessmentMutation = { __typename?: 'Mutation', completeAssessment: { __typename?: 'CompleteAssessmentPayload', success: boolean, errors: Array<string>, session: { __typename?: 'OnboardingSession', id: string, status: string } | null } | null };

export type CreateSessionMutationVariables = Exact<{
  referralSource?: InputMaybe<Scalars['String']['input']>;
  deviceFingerprint?: InputMaybe<Scalars['String']['input']>;
}>;


export type CreateSessionMutation = { __typename?: 'Mutation', createSession: { __typename?: 'CreateSessionPayload', token: string, refreshToken: string | null, session: { __typename?: 'OnboardingSession', id: string, status: string, expiresAt: any, createdAt: any, progress: { __typename?: 'Progress', percentage: number, currentPhase: string, completedPhases: Array<string>, nextPhase: string | null, estimatedMinutesRemaining: number } } } | null };

export type RefreshTokenMutationVariables = Exact<{
  refreshToken: Scalars['String']['input'];
  deviceFingerprint?: InputMaybe<Scalars['String']['input']>;
}>;


export type RefreshTokenMutation = { __typename?: 'Mutation', refreshToken: { __typename?: 'RefreshTokenPayload', success: boolean, error: string | null, token: string | null, refreshToken: string | null, tokenType: string | null, expiresIn: number | null } | null };

export type RequestSessionRecoveryMutationVariables = Exact<{
  input: RequestRecoveryInput;
}>;


export type RequestSessionRecoveryMutation = { __typename?: 'Mutation', requestSessionRecovery: { __typename?: 'RequestRecoveryPayload', success: boolean, message: string } | null };

export type SendMessageMutationVariables = Exact<{
  sessionId: Scalars['ID']['input'];
  content: Scalars['String']['input'];
}>;


export type SendMessageMutation = { __typename?: 'Mutation', sendMessage: { __typename?: 'SendMessagePayload', errors: Array<string>, userMessage: { __typename?: 'Message', id: string, role: string, content: string, createdAt: any } | null, assistantMessage: { __typename?: 'Message', id: string, role: string, content: string, createdAt: any } | null } | null };

export type SelectSelfPayMutationVariables = Exact<{
  input: SelectSelfPayInput;
}>;


export type SelectSelfPayMutation = { __typename?: 'Mutation', selectSelfPay: { __typename?: 'SelectSelfPayPayload', success: boolean, session: { __typename?: 'OnboardingSession', id: string, status: string, insurance: { __typename?: 'Insurance', id: string, verificationStatus: string } | null } } | null };

export type SubmitAssessmentResponseMutationVariables = Exact<{
  sessionId: Scalars['ID']['input'];
  questionId: Scalars['String']['input'];
  responseText: Scalars['String']['input'];
  responseValue?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SubmitAssessmentResponseMutation = { __typename?: 'Mutation', submitAssessmentResponse: { __typename?: 'SubmitResponsePayload', errors: Array<string>, assessment: { __typename?: 'Assessment', id: string, status: string, score: number | null } | null, nextQuestion: { __typename?: 'AssessmentQuestion', id: string, text: string, instrument: string } | null, progress: { __typename?: 'AssessmentProgress', status: string, completedQuestions: number, totalQuestions: number, percentage: number, phqAComplete: boolean, gad7Complete: boolean, currentPhase: string } | null } | null };

export type SubmitChildInfoMutationVariables = Exact<{
  session_id: Scalars['ID']['input'];
  child_info: ChildInput;
}>;


export type SubmitChildInfoMutation = { __typename?: 'Mutation', submitChildInfo: { __typename?: 'SubmitChildInfoPayload', errors: Array<string>, child: { __typename?: 'Child', id: string, first_name: string, last_name: string, date_of_birth: string, gender: string | null, school_name: string | null, grade: string | null, primary_concerns: string | null } | null, session: { __typename?: 'OnboardingSession', id: string, status: string } | null } | null };

export type SubmitInsuranceInfoMutationVariables = Exact<{
  sessionId: Scalars['ID']['input'];
  payerName?: InputMaybe<Scalars['String']['input']>;
  subscriberName?: InputMaybe<Scalars['String']['input']>;
  memberId?: InputMaybe<Scalars['String']['input']>;
  groupNumber?: InputMaybe<Scalars['String']['input']>;
  subscriberDob?: InputMaybe<Scalars['String']['input']>;
}>;


export type SubmitInsuranceInfoMutation = { __typename?: 'Mutation', submitInsuranceInfo: { __typename?: 'SubmitInfoPayload', prePopulatedFromOcr: boolean, insurance: { __typename?: 'Insurance', id: string, payerName: string | null, subscriberName: string | null, memberId: string | null, groupNumber: string | null, verificationStatus: string } | null, errors: Array<{ __typename?: 'FieldError', field: string, message: string }> } | null };

export type SubmitParentInfoMutationVariables = Exact<{
  sessionId: Scalars['ID']['input'];
  parentInfo: ParentInput;
}>;


export type SubmitParentInfoMutation = { __typename?: 'Mutation', submitParentInfo: { __typename?: 'SubmitParentInfoPayload', errors: Array<string>, parent: { __typename?: 'Parent', id: string, firstName: string, lastName: string, email: string, phone: string, relationship: string, isGuardian: boolean } | null } | null };

export type UpdateSessionProgressMutationVariables = Exact<{
  input: UpdateSessionProgressInput;
}>;


export type UpdateSessionProgressMutation = { __typename?: 'Mutation', updateSessionProgress: { __typename?: 'UpdateSessionProgressPayload', session: { __typename?: 'OnboardingSession', id: string, status: string, expiresAt: any, updatedAt: any, progress: { __typename?: 'Progress', percentage: number, currentPhase: string, completedPhases: Array<string>, nextPhase: string | null, estimatedMinutesRemaining: number } } } | null };

export type UploadInsuranceCardMutationVariables = Exact<{
  sessionId: Scalars['ID']['input'];
  frontImage: Scalars['Upload']['input'];
  backImage?: InputMaybe<Scalars['Upload']['input']>;
}>;


export type UploadInsuranceCardMutation = { __typename?: 'Mutation', uploadInsuranceCard: { __typename?: 'UploadCardPayload', errors: Array<string>, insurance: { __typename?: 'Insurance', id: string, payerName: string | null, subscriberName: string | null, memberId: string | null, groupNumber: string | null, verificationStatus: string, cardImageFrontUrl: string | null, cardImageBackUrl: string | null, ocrProcessed: boolean, ocrExtracted: Record<string, unknown> | null, ocrConfidence: Record<string, unknown> | null, ocrLowConfidenceFields: Array<string> | null, needsReview: boolean, ocrError: Record<string, unknown> | null } | null } | null };

export type GetIntercomContextQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type GetIntercomContextQuery = { __typename?: 'Query', generateIntercomContext: { __typename?: 'IntercomContext', sessionId: string, onboardingPhase: string, parentFirstName: string | null, childAge: number | null, insuranceStatus: string | null, hasErrors: boolean, errorType: string | null, adminLink: string } };

export type GetIntercomIdentityQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type GetIntercomIdentityQuery = { __typename?: 'Query', intercomIdentity: { __typename?: 'IntercomIdentity', appId: string | null, userJwt: string | null, userId: string, enabled: boolean } };

export type GetSessionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetSessionQuery = { __typename?: 'Query', session: { __typename?: 'OnboardingSession', id: string, status: string, referralSource: string | null, expiresAt: any, createdAt: any, updatedAt: any, progress: { __typename?: 'Progress', percentage: number, currentPhase: string, completedPhases: Array<string>, nextPhase: string | null, estimatedMinutesRemaining: number }, parent: { __typename?: 'Parent', id: string, email: string, phone: string, firstName: string, lastName: string, relationship: string, isGuardian: boolean } | null, child: { __typename?: 'Child', id: string, first_name: string, last_name: string, date_of_birth: string, gender: string | null, school_name: string | null, grade: string | null } | null, assessment: { __typename?: 'Assessment', id: string, status: string, responses: Record<string, unknown>, riskFlags: Array<string>, summary: string | null, consentGiven: boolean, score: number | null } | null, insurance: { __typename?: 'Insurance', id: string, payerName: string | null, subscriberName: string | null, memberId: string | null, policyNumber: string | null, groupNumber: string | null, verificationStatus: string } | null, messages: Array<{ __typename?: 'Message', id: string, role: string, content: string, createdAt: any }> | null } };

export type GetSelfPayRatesQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type GetSelfPayRatesQuery = { __typename?: 'Query', costComparison: { __typename?: 'CostComparison', highlightSelfPay: boolean, selfPayEstimate: { __typename?: 'SelfPayEstimate', baseRate: string, totalForTypicalTreatment: string, slidingScaleInfo: string | null, transparentPricingMessage: string, whatIsIncluded: Array<string>, whatIsNotIncluded: Array<string>, packageOptions: Array<{ __typename?: 'PackageOption', sessions: number, totalPrice: string, perSessionCost: string, savings: string, description: string }> } }, financialAssistanceInfo: { __typename?: 'FinancialAssistance', available: boolean, eligibilityCriteria: Array<string>, applicationUrl: string, description: string, slidingScaleAvailable: boolean, discountRange: string } };

export type GetSuggestedRepliesQueryVariables = Exact<{
  sessionId: Scalars['ID']['input'];
  messageId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GetSuggestedRepliesQuery = { __typename?: 'Query', suggestedReplies: Array<{ __typename?: 'QuickReplyOption', label: string, value: string, icon: string | null }> };

export type SessionByRecoveryTokenQueryVariables = Exact<{
  recoveryToken: Scalars['String']['input'];
}>;


export type SessionByRecoveryTokenQuery = { __typename?: 'Query', sessionByRecoveryToken: { __typename?: 'SessionRecoveryPayload', token: string, refreshToken: string, session: { __typename?: 'OnboardingSession', id: string, status: string, expiresAt: any, createdAt: any, updatedAt: any, progress: { __typename?: 'Progress', percentage: number, currentPhase: string, completedPhases: Array<string>, nextPhase: string | null, estimatedMinutesRemaining: number } } } };

export type InsuranceStatusChangedSubscriptionVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type InsuranceStatusChangedSubscription = { __typename?: 'Subscription', insuranceStatusChanged: { __typename?: 'InsuranceStatusChangedPayload', insurance: { __typename?: 'Insurance', id: string, payerName: string | null, subscriberName: string | null, memberId: string | null, groupNumber: string | null, verificationStatus: string, ocrProcessed: boolean, ocrExtracted: Record<string, unknown> | null, ocrConfidence: Record<string, unknown> | null, ocrLowConfidenceFields: Array<string> | null, needsReview: boolean, ocrError: Record<string, unknown> | null, ocrDataAvailable: boolean }, progress: { __typename?: 'VerificationProgress', percentage: number, message: string } | null } };

export type SessionUpdatedSubscriptionVariables = Exact<{
  sessionId: Scalars['ID']['input'];
}>;


export type SessionUpdatedSubscription = { __typename?: 'Subscription', sessionUpdated: { __typename?: 'SessionUpdatedPayload', session: { __typename?: 'OnboardingSession', id: string, status: string, expiresAt: any, updatedAt: any, progress: { __typename?: 'Progress', percentage: number, currentPhase: string, completedPhases: Array<string>, nextPhase: string | null, estimatedMinutesRemaining: number } } } };


export const GetCostEstimateDocument = gql`
    query GetCostEstimate($sessionId: ID!) {
  costComparison(sessionId: $sessionId) {
    insuranceEstimate {
      perSessionCost
      totalEstimatedCost
      explanation
      assumptionNotes
    }
    selfPayEstimate {
      baseRate
      totalForTypicalTreatment
      slidingScaleInfo
      packageOptions {
        sessions
        totalPrice
        perSessionCost
        savings
        description
      }
      transparentPricingMessage
      whatIsIncluded
      whatIsNotIncluded
    }
    comparisonTable {
      label
      insuranceValue
      selfPayValue
      highlightSelfPay
    }
    recommendation
    savingsIfSelfPay
    highlightSelfPay
  }
}
    `;
export function useGetCostEstimateQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetCostEstimateQuery, GetCostEstimateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetCostEstimateQuery, GetCostEstimateQueryVariables>(GetCostEstimateDocument, options);
      }
export function useGetCostEstimateLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetCostEstimateQuery, GetCostEstimateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetCostEstimateQuery, GetCostEstimateQueryVariables>(GetCostEstimateDocument, options);
        }
export type GetCostEstimateQueryHookResult = ReturnType<typeof useGetCostEstimateQuery>;
export type GetCostEstimateLazyQueryHookResult = ReturnType<typeof useGetCostEstimateLazyQuery>;
export const GetEnhancedCostComparisonDocument = gql`
    query GetEnhancedCostComparison($sessionId: ID!) {
  costComparison(sessionId: $sessionId) {
    insuranceEstimate {
      perSessionCost
      totalEstimatedCost
      explanation
      assumptionNotes
    }
    selfPayEstimate {
      baseRate
      totalForTypicalTreatment
      slidingScaleInfo
      transparentPricingMessage
      whatIsIncluded
      whatIsNotIncluded
      packageOptions {
        sessions
        totalPrice
        perSessionCost
        savings
        description
      }
    }
    comparisonTable {
      label
      insuranceValue
      selfPayValue
      highlightSelfPay
    }
    recommendation
    savingsIfSelfPay
    highlightSelfPay
  }
  deductibleStatus(sessionId: $sessionId) {
    amount
    met
    remaining
    progressPercentage
    isMet
    oopMaxAmount
    oopMet
    oopRemaining
    oopProgressPercentage
  }
  session(id: $sessionId) {
    insurance {
      cardImageFrontUrl
      cardImageBackUrl
      payerName
      memberId
      copayAmount
      coinsurancePercentage
      deductibleAmount
      deductibleMet
    }
  }
}
    `;
export function useGetEnhancedCostComparisonQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetEnhancedCostComparisonQuery, GetEnhancedCostComparisonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetEnhancedCostComparisonQuery, GetEnhancedCostComparisonQueryVariables>(GetEnhancedCostComparisonDocument, options);
      }
export function useGetEnhancedCostComparisonLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetEnhancedCostComparisonQuery, GetEnhancedCostComparisonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetEnhancedCostComparisonQuery, GetEnhancedCostComparisonQueryVariables>(GetEnhancedCostComparisonDocument, options);
        }
export type GetEnhancedCostComparisonQueryHookResult = ReturnType<typeof useGetEnhancedCostComparisonQuery>;
export type GetEnhancedCostComparisonLazyQueryHookResult = ReturnType<typeof useGetEnhancedCostComparisonLazyQuery>;
export const GetPaymentPlansDocument = gql`
    query GetPaymentPlans($sessionId: ID!, $estimatedCost: Float!) {
  paymentPlanOptions(sessionId: $sessionId, estimatedCost: $estimatedCost) {
    durationMonths
    monthlyAmount
    totalAmount
    interestRate
    hasFees
    feeAmount
    upfrontDiscount
    description
  }
  financialAssistanceInfo {
    available
    eligibilityCriteria
    applicationUrl
    description
    slidingScaleAvailable
    discountRange
    additionalInfo
  }
}
    `;
export function useGetPaymentPlansQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetPaymentPlansQuery, GetPaymentPlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetPaymentPlansQuery, GetPaymentPlansQueryVariables>(GetPaymentPlansDocument, options);
      }
export function useGetPaymentPlansLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetPaymentPlansQuery, GetPaymentPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetPaymentPlansQuery, GetPaymentPlansQueryVariables>(GetPaymentPlansDocument, options);
        }
export type GetPaymentPlansQueryHookResult = ReturnType<typeof useGetPaymentPlansQuery>;
export type GetPaymentPlansLazyQueryHookResult = ReturnType<typeof useGetPaymentPlansLazyQuery>;
export const SavePaymentPlanSelectionDocument = gql`
    mutation SavePaymentPlanSelection($input: SavePaymentPlanSelectionInput!) {
  savePaymentPlanSelection(input: $input) {
    success
    paymentPlan {
      id
      planDurationMonths
      monthlyAmount
      totalAmount
      discountApplied
      paymentMethodPreference
      status
      description
    }
  }
}
    `;
export function useSavePaymentPlanSelectionMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SavePaymentPlanSelectionMutation, SavePaymentPlanSelectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<SavePaymentPlanSelectionMutation, SavePaymentPlanSelectionMutationVariables>(SavePaymentPlanSelectionDocument, options);
      }
export type SavePaymentPlanSelectionMutationHookResult = ReturnType<typeof useSavePaymentPlanSelectionMutation>;
export const GetMatchedTherapistsDocument = gql`
    query GetMatchedTherapists($sessionId: ID!) {
  matchedTherapists(sessionId: $sessionId) {
    therapists {
      id
      name
      credentials
      photoUrl
      specialties
      availabilityStatus
      availabilityText
      yearsOfExperience
      bio
      matchScore
      isBestMatch
      matchReasons {
        id
        text
        icon
      }
    }
    totalCount
    matchingCriteria
  }
}
    `;
export function useGetMatchedTherapistsQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetMatchedTherapistsQuery, GetMatchedTherapistsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetMatchedTherapistsQuery, GetMatchedTherapistsQueryVariables>(GetMatchedTherapistsDocument, options);
      }
export function useGetMatchedTherapistsLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetMatchedTherapistsQuery, GetMatchedTherapistsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetMatchedTherapistsQuery, GetMatchedTherapistsQueryVariables>(GetMatchedTherapistsDocument, options);
        }
export type GetMatchedTherapistsQueryHookResult = ReturnType<typeof useGetMatchedTherapistsQuery>;
export type GetMatchedTherapistsLazyQueryHookResult = ReturnType<typeof useGetMatchedTherapistsLazyQuery>;
export const GetTherapistProfileDocument = gql`
    query GetTherapistProfile($therapistId: ID!, $sessionId: ID!) {
  therapistProfile(therapistId: $therapistId, sessionId: $sessionId) {
    id
    name
    credentials
    photoUrl
    bio
    specialties
    yearsOfExperience
    approach
    languages
    education {
      degree
      institution
      year
    }
    certifications
    matchReasons(sessionId: $sessionId) {
      id
      text
      icon
    }
    availabilityStatus
    availabilityText
    availableSlots(limit: 3) {
      startTime
      endTime
      therapistId
      durationMinutes
    }
  }
}
    `;
export function useGetTherapistProfileQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetTherapistProfileQuery, GetTherapistProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetTherapistProfileQuery, GetTherapistProfileQueryVariables>(GetTherapistProfileDocument, options);
      }
export function useGetTherapistProfileLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetTherapistProfileQuery, GetTherapistProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetTherapistProfileQuery, GetTherapistProfileQueryVariables>(GetTherapistProfileDocument, options);
        }
export type GetTherapistProfileQueryHookResult = ReturnType<typeof useGetTherapistProfileQuery>;
export type GetTherapistProfileLazyQueryHookResult = ReturnType<typeof useGetTherapistProfileLazyQuery>;
export const BookAppointmentDocument = gql`
    mutation BookAppointment($input: BookAppointmentInput!) {
  bookAppointment(input: $input) {
    appointment {
      id
      onboardingSessionId
      scheduledAt
      durationMinutes
      status
      virtualLink
      confirmationNumber
      therapist {
        id
        fullName
        licenseType
        photoUrl
      }
    }
    success
    errors
  }
}
    `;
export function useBookAppointmentMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<BookAppointmentMutation, BookAppointmentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<BookAppointmentMutation, BookAppointmentMutationVariables>(BookAppointmentDocument, options);
      }
export type BookAppointmentMutationHookResult = ReturnType<typeof useBookAppointmentMutation>;
export const GetTherapistAvailabilityDocument = gql`
    query GetTherapistAvailability($therapistId: ID!, $startDate: ISO8601DateTime!, $endDate: ISO8601DateTime!, $timezone: String, $sessionId: ID) {
  therapistAvailability(
    therapistId: $therapistId
    startDate: $startDate
    endDate: $endDate
    timezone: $timezone
    sessionId: $sessionId
  ) {
    therapistId
    therapistName
    therapistPhotoUrl
    timezone
    availableDates {
      date
      hasAvailability
      slots {
        id
        startTime
        endTime
        isAvailable
        timezone
      }
    }
  }
}
    `;
export function useGetTherapistAvailabilityQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetTherapistAvailabilityQuery, GetTherapistAvailabilityQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetTherapistAvailabilityQuery, GetTherapistAvailabilityQueryVariables>(GetTherapistAvailabilityDocument, options);
      }
export function useGetTherapistAvailabilityLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetTherapistAvailabilityQuery, GetTherapistAvailabilityQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetTherapistAvailabilityQuery, GetTherapistAvailabilityQueryVariables>(GetTherapistAvailabilityDocument, options);
        }
export type GetTherapistAvailabilityQueryHookResult = ReturnType<typeof useGetTherapistAvailabilityQuery>;
export type GetTherapistAvailabilityLazyQueryHookResult = ReturnType<typeof useGetTherapistAvailabilityLazyQuery>;
export const AbandonSessionDocument = gql`
    mutation AbandonSession($input: AbandonSessionInput!) {
  abandonSession(input: $input) {
    session {
      id
      status
    }
    success
  }
}
    `;
export function useAbandonSessionMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<AbandonSessionMutation, AbandonSessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<AbandonSessionMutation, AbandonSessionMutationVariables>(AbandonSessionDocument, options);
      }
export type AbandonSessionMutationHookResult = ReturnType<typeof useAbandonSessionMutation>;
export const CompleteAssessmentDocument = gql`
    mutation CompleteAssessment($input: CompleteAssessmentInput!) {
  completeAssessment(input: $input) {
    session {
      id
      status
    }
    success
    errors
  }
}
    `;
export function useCompleteAssessmentMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<CompleteAssessmentMutation, CompleteAssessmentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<CompleteAssessmentMutation, CompleteAssessmentMutationVariables>(CompleteAssessmentDocument, options);
      }
export type CompleteAssessmentMutationHookResult = ReturnType<typeof useCompleteAssessmentMutation>;
export const CreateSessionDocument = gql`
    mutation CreateSession($referralSource: String, $deviceFingerprint: String) {
  createSession(
    referralSource: $referralSource
    deviceFingerprint: $deviceFingerprint
  ) {
    session {
      id
      status
      progress {
        percentage
        currentPhase
        completedPhases
        nextPhase
        estimatedMinutesRemaining
      }
      expiresAt
      createdAt
    }
    token
    refreshToken
  }
}
    `;
export function useCreateSessionMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<CreateSessionMutation, CreateSessionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<CreateSessionMutation, CreateSessionMutationVariables>(CreateSessionDocument, options);
      }
export type CreateSessionMutationHookResult = ReturnType<typeof useCreateSessionMutation>;
export const RefreshTokenDocument = gql`
    mutation RefreshToken($refreshToken: String!, $deviceFingerprint: String) {
  refreshToken(refreshToken: $refreshToken, deviceFingerprint: $deviceFingerprint) {
    success
    error
    token
    refreshToken
    tokenType
    expiresIn
  }
}
    `;
export function useRefreshTokenMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<RefreshTokenMutation, RefreshTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<RefreshTokenMutation, RefreshTokenMutationVariables>(RefreshTokenDocument, options);
      }
export type RefreshTokenMutationHookResult = ReturnType<typeof useRefreshTokenMutation>;
export const RequestSessionRecoveryDocument = gql`
    mutation RequestSessionRecovery($input: RequestRecoveryInput!) {
  requestSessionRecovery(input: $input) {
    success
    message
  }
}
    `;
export function useRequestSessionRecoveryMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<RequestSessionRecoveryMutation, RequestSessionRecoveryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<RequestSessionRecoveryMutation, RequestSessionRecoveryMutationVariables>(RequestSessionRecoveryDocument, options);
      }
export type RequestSessionRecoveryMutationHookResult = ReturnType<typeof useRequestSessionRecoveryMutation>;
export const SendMessageDocument = gql`
    mutation SendMessage($sessionId: ID!, $content: String!) {
  sendMessage(sessionId: $sessionId, content: $content) {
    userMessage {
      id
      role
      content
      createdAt
    }
    assistantMessage {
      id
      role
      content
      createdAt
    }
    errors
  }
}
    `;
export function useSendMessageMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SendMessageMutation, SendMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<SendMessageMutation, SendMessageMutationVariables>(SendMessageDocument, options);
      }
export type SendMessageMutationHookResult = ReturnType<typeof useSendMessageMutation>;
export const SelectSelfPayDocument = gql`
    mutation SelectSelfPay($input: SelectSelfPayInput!) {
  selectSelfPay(input: $input) {
    success
    session {
      id
      status
      insurance {
        id
        verificationStatus
      }
    }
  }
}
    `;
export function useSelectSelfPayMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SelectSelfPayMutation, SelectSelfPayMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<SelectSelfPayMutation, SelectSelfPayMutationVariables>(SelectSelfPayDocument, options);
      }
export type SelectSelfPayMutationHookResult = ReturnType<typeof useSelectSelfPayMutation>;
export const SubmitAssessmentResponseDocument = gql`
    mutation SubmitAssessmentResponse($sessionId: ID!, $questionId: String!, $responseText: String!, $responseValue: Int) {
  submitAssessmentResponse(
    sessionId: $sessionId
    questionId: $questionId
    responseText: $responseText
    responseValue: $responseValue
  ) {
    assessment {
      id
      status
      score
    }
    nextQuestion {
      id
      text
      instrument
    }
    progress {
      status
      completedQuestions
      totalQuestions
      percentage
      phqAComplete
      gad7Complete
      currentPhase
    }
    errors
  }
}
    `;
export function useSubmitAssessmentResponseMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SubmitAssessmentResponseMutation, SubmitAssessmentResponseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<SubmitAssessmentResponseMutation, SubmitAssessmentResponseMutationVariables>(SubmitAssessmentResponseDocument, options);
      }
export type SubmitAssessmentResponseMutationHookResult = ReturnType<typeof useSubmitAssessmentResponseMutation>;
export const SubmitChildInfoDocument = gql`
    mutation SubmitChildInfo($session_id: ID!, $child_info: ChildInput!) {
  submitChildInfo(session_id: $session_id, child_info: $child_info) {
    child {
      id
      first_name
      last_name
      date_of_birth
      gender
      school_name
      grade
      primary_concerns
    }
    session {
      id
      status
    }
    errors
  }
}
    `;
export function useSubmitChildInfoMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SubmitChildInfoMutation, SubmitChildInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<SubmitChildInfoMutation, SubmitChildInfoMutationVariables>(SubmitChildInfoDocument, options);
      }
export type SubmitChildInfoMutationHookResult = ReturnType<typeof useSubmitChildInfoMutation>;
export const SubmitInsuranceInfoDocument = gql`
    mutation SubmitInsuranceInfo($sessionId: ID!, $payerName: String, $subscriberName: String, $memberId: String, $groupNumber: String, $subscriberDob: String) {
  submitInsuranceInfo(
    sessionId: $sessionId
    payerName: $payerName
    subscriberName: $subscriberName
    memberId: $memberId
    groupNumber: $groupNumber
    subscriberDob: $subscriberDob
  ) {
    insurance {
      id
      payerName
      subscriberName
      memberId
      groupNumber
      verificationStatus
    }
    errors {
      field
      message
    }
    prePopulatedFromOcr
  }
}
    `;
export function useSubmitInsuranceInfoMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SubmitInsuranceInfoMutation, SubmitInsuranceInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<SubmitInsuranceInfoMutation, SubmitInsuranceInfoMutationVariables>(SubmitInsuranceInfoDocument, options);
      }
export type SubmitInsuranceInfoMutationHookResult = ReturnType<typeof useSubmitInsuranceInfoMutation>;
export const SubmitParentInfoDocument = gql`
    mutation SubmitParentInfo($sessionId: ID!, $parentInfo: ParentInput!) {
  submitParentInfo(sessionId: $sessionId, parentInfo: $parentInfo) {
    parent {
      id
      firstName
      lastName
      email
      phone
      relationship
      isGuardian
    }
    errors
  }
}
    `;
export function useSubmitParentInfoMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SubmitParentInfoMutation, SubmitParentInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<SubmitParentInfoMutation, SubmitParentInfoMutationVariables>(SubmitParentInfoDocument, options);
      }
export type SubmitParentInfoMutationHookResult = ReturnType<typeof useSubmitParentInfoMutation>;
export const UpdateSessionProgressDocument = gql`
    mutation UpdateSessionProgress($input: UpdateSessionProgressInput!) {
  updateSessionProgress(input: $input) {
    session {
      id
      status
      progress {
        percentage
        currentPhase
        completedPhases
        nextPhase
        estimatedMinutesRemaining
      }
      expiresAt
      updatedAt
    }
  }
}
    `;
export function useUpdateSessionProgressMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateSessionProgressMutation, UpdateSessionProgressMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<UpdateSessionProgressMutation, UpdateSessionProgressMutationVariables>(UpdateSessionProgressDocument, options);
      }
export type UpdateSessionProgressMutationHookResult = ReturnType<typeof useUpdateSessionProgressMutation>;
export const UploadInsuranceCardDocument = gql`
    mutation UploadInsuranceCard($sessionId: ID!, $frontImage: Upload!, $backImage: Upload) {
  uploadInsuranceCard(
    sessionId: $sessionId
    frontImage: $frontImage
    backImage: $backImage
  ) {
    insurance {
      id
      payerName
      subscriberName
      memberId
      groupNumber
      verificationStatus
      cardImageFrontUrl
      cardImageBackUrl
      ocrProcessed
      ocrExtracted
      ocrConfidence
      ocrLowConfidenceFields
      needsReview
      ocrError
    }
    errors
  }
}
    `;
export function useUploadInsuranceCardMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<UploadInsuranceCardMutation, UploadInsuranceCardMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useMutation<UploadInsuranceCardMutation, UploadInsuranceCardMutationVariables>(UploadInsuranceCardDocument, options);
      }
export type UploadInsuranceCardMutationHookResult = ReturnType<typeof useUploadInsuranceCardMutation>;
export const GetIntercomContextDocument = gql`
    query GetIntercomContext($sessionId: ID!) {
  generateIntercomContext(sessionId: $sessionId) {
    sessionId
    onboardingPhase
    parentFirstName
    childAge
    insuranceStatus
    hasErrors
    errorType
    adminLink
  }
}
    `;
export function useGetIntercomContextQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetIntercomContextQuery, GetIntercomContextQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetIntercomContextQuery, GetIntercomContextQueryVariables>(GetIntercomContextDocument, options);
      }
export function useGetIntercomContextLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetIntercomContextQuery, GetIntercomContextQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetIntercomContextQuery, GetIntercomContextQueryVariables>(GetIntercomContextDocument, options);
        }
export type GetIntercomContextQueryHookResult = ReturnType<typeof useGetIntercomContextQuery>;
export type GetIntercomContextLazyQueryHookResult = ReturnType<typeof useGetIntercomContextLazyQuery>;
export const GetIntercomIdentityDocument = gql`
    query GetIntercomIdentity($sessionId: ID!) {
  intercomIdentity(sessionId: $sessionId) {
    appId
    userJwt
    userId
    enabled
  }
}
    `;
export function useGetIntercomIdentityQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetIntercomIdentityQuery, GetIntercomIdentityQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetIntercomIdentityQuery, GetIntercomIdentityQueryVariables>(GetIntercomIdentityDocument, options);
      }
export function useGetIntercomIdentityLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetIntercomIdentityQuery, GetIntercomIdentityQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetIntercomIdentityQuery, GetIntercomIdentityQueryVariables>(GetIntercomIdentityDocument, options);
        }
export type GetIntercomIdentityQueryHookResult = ReturnType<typeof useGetIntercomIdentityQuery>;
export type GetIntercomIdentityLazyQueryHookResult = ReturnType<typeof useGetIntercomIdentityLazyQuery>;
export const GetSessionDocument = gql`
    query GetSession($id: ID!) {
  session(id: $id) {
    id
    status
    progress {
      percentage
      currentPhase
      completedPhases
      nextPhase
      estimatedMinutesRemaining
    }
    referralSource
    expiresAt
    createdAt
    updatedAt
    parent {
      id
      email
      phone
      firstName
      lastName
      relationship
      isGuardian
    }
    child {
      id
      first_name
      last_name
      date_of_birth
      gender
      school_name
      grade
    }
    assessment {
      id
      status
      responses
      riskFlags
      summary
      consentGiven
      score
    }
    insurance {
      id
      payerName
      subscriberName
      memberId
      policyNumber
      groupNumber
      verificationStatus
    }
    messages {
      id
      role
      content
      createdAt
    }
  }
}
    `;
export function useGetSessionQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetSessionQuery, GetSessionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetSessionQuery, GetSessionQueryVariables>(GetSessionDocument, options);
      }
export function useGetSessionLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetSessionQuery, GetSessionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetSessionQuery, GetSessionQueryVariables>(GetSessionDocument, options);
        }
export type GetSessionQueryHookResult = ReturnType<typeof useGetSessionQuery>;
export type GetSessionLazyQueryHookResult = ReturnType<typeof useGetSessionLazyQuery>;
export const GetSelfPayRatesDocument = gql`
    query GetSelfPayRates($sessionId: ID!) {
  costComparison(sessionId: $sessionId) {
    selfPayEstimate {
      baseRate
      totalForTypicalTreatment
      slidingScaleInfo
      packageOptions {
        sessions
        totalPrice
        perSessionCost
        savings
        description
      }
      transparentPricingMessage
      whatIsIncluded
      whatIsNotIncluded
    }
    highlightSelfPay
  }
  financialAssistanceInfo {
    available
    eligibilityCriteria
    applicationUrl
    description
    slidingScaleAvailable
    discountRange
  }
}
    `;
export function useGetSelfPayRatesQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetSelfPayRatesQuery, GetSelfPayRatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetSelfPayRatesQuery, GetSelfPayRatesQueryVariables>(GetSelfPayRatesDocument, options);
      }
export function useGetSelfPayRatesLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetSelfPayRatesQuery, GetSelfPayRatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetSelfPayRatesQuery, GetSelfPayRatesQueryVariables>(GetSelfPayRatesDocument, options);
        }
export type GetSelfPayRatesQueryHookResult = ReturnType<typeof useGetSelfPayRatesQuery>;
export type GetSelfPayRatesLazyQueryHookResult = ReturnType<typeof useGetSelfPayRatesLazyQuery>;
export const GetSuggestedRepliesDocument = gql`
    query GetSuggestedReplies($sessionId: ID!, $messageId: ID) {
  suggestedReplies(sessionId: $sessionId, messageId: $messageId) {
    label
    value
    icon
  }
}
    `;
export function useGetSuggestedRepliesQuery(baseOptions: ApolloReactHooks.QueryHookOptions<GetSuggestedRepliesQuery, GetSuggestedRepliesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<GetSuggestedRepliesQuery, GetSuggestedRepliesQueryVariables>(GetSuggestedRepliesDocument, options);
      }
export function useGetSuggestedRepliesLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<GetSuggestedRepliesQuery, GetSuggestedRepliesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<GetSuggestedRepliesQuery, GetSuggestedRepliesQueryVariables>(GetSuggestedRepliesDocument, options);
        }
export type GetSuggestedRepliesQueryHookResult = ReturnType<typeof useGetSuggestedRepliesQuery>;
export type GetSuggestedRepliesLazyQueryHookResult = ReturnType<typeof useGetSuggestedRepliesLazyQuery>;
export const SessionByRecoveryTokenDocument = gql`
    query SessionByRecoveryToken($recoveryToken: String!) {
  sessionByRecoveryToken(recoveryToken: $recoveryToken) {
    session {
      id
      status
      progress {
        percentage
        currentPhase
        completedPhases
        nextPhase
        estimatedMinutesRemaining
      }
      expiresAt
      createdAt
      updatedAt
    }
    token
    refreshToken
  }
}
    `;
export function useSessionByRecoveryTokenQuery(baseOptions: ApolloReactHooks.QueryHookOptions<SessionByRecoveryTokenQuery, SessionByRecoveryTokenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useQuery<SessionByRecoveryTokenQuery, SessionByRecoveryTokenQueryVariables>(SessionByRecoveryTokenDocument, options);
      }
export function useSessionByRecoveryTokenLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<SessionByRecoveryTokenQuery, SessionByRecoveryTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return ApolloReactHooks.useLazyQuery<SessionByRecoveryTokenQuery, SessionByRecoveryTokenQueryVariables>(SessionByRecoveryTokenDocument, options);
        }
export type SessionByRecoveryTokenQueryHookResult = ReturnType<typeof useSessionByRecoveryTokenQuery>;
export type SessionByRecoveryTokenLazyQueryHookResult = ReturnType<typeof useSessionByRecoveryTokenLazyQuery>;
export const InsuranceStatusChangedDocument = gql`
    subscription InsuranceStatusChanged($sessionId: ID!) {
  insuranceStatusChanged(sessionId: $sessionId) {
    insurance {
      id
      payerName
      subscriberName
      memberId
      groupNumber
      verificationStatus
      ocrProcessed
      ocrExtracted
      ocrConfidence
      ocrLowConfidenceFields
      needsReview
      ocrError
      ocrDataAvailable
    }
    progress {
      percentage
      message
    }
  }
}
    `;
export function useInsuranceStatusChangedSubscription(baseOptions: ApolloReactHooks.SubscriptionHookOptions<InsuranceStatusChangedSubscription, InsuranceStatusChangedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useSubscription<InsuranceStatusChangedSubscription, InsuranceStatusChangedSubscriptionVariables>(InsuranceStatusChangedDocument, options);
      }
export type InsuranceStatusChangedSubscriptionHookResult = ReturnType<typeof useInsuranceStatusChangedSubscription>;
export const SessionUpdatedDocument = gql`
    subscription SessionUpdated($sessionId: ID!) {
  sessionUpdated(sessionId: $sessionId) {
    session {
      id
      status
      progress {
        percentage
        currentPhase
        completedPhases
        nextPhase
        estimatedMinutesRemaining
      }
      expiresAt
      updatedAt
    }
  }
}
    `;
export function useSessionUpdatedSubscription(baseOptions: ApolloReactHooks.SubscriptionHookOptions<SessionUpdatedSubscription, SessionUpdatedSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return ApolloReactHooks.useSubscription<SessionUpdatedSubscription, SessionUpdatedSubscriptionVariables>(SessionUpdatedDocument, options);
      }
export type SessionUpdatedSubscriptionHookResult = ReturnType<typeof useSessionUpdatedSubscription>;