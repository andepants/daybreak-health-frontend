/**
 * Custom hook for fetching and managing payment plan data
 *
 * Provides a clean interface for components to access payment plan options
 * and select a payment plan for a given onboarding session.
 * Integrates with Apollo Client caching for optimal performance.
 *
 * Features:
 * - Automatic query execution on mount
 * - Loading and error state management
 * - Apollo cache integration with cache-first policy
 * - Type-safe data access
 * - Payment plan selection mutation
 *
 * Security:
 * - Session-scoped data (only session ID exposed)
 * - No PHI concerns (payment plans are configuration)
 */

import { useQuery, useMutation } from "@apollo/client/react";
import { useMemo } from "react";
import type { PaymentPlan } from "@/lib/validations/cost";

// Note: These imports will be auto-generated by GraphQL Code Generator
// For now, these are placeholders until codegen runs
// The actual imports will be:
// import { GetPaymentPlansDocument, SetPaymentPreferenceDocument } from '@/types/graphql';
const GET_PAYMENT_PLANS = null as any; // Placeholder until codegen runs
const SET_PAYMENT_PREFERENCE = null as any; // Placeholder until codegen runs

/**
 * Hook return type
 */
export interface UsePaymentPlansResult {
  paymentPlans: PaymentPlan[] | null;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
  selectPlan: (planId: string) => Promise<void>;
  selecting: boolean;
  selectError: Error | null;
}

/**
 * Fetches payment plan options and provides selection functionality
 *
 * Executes GraphQL query to retrieve available payment plan options for
 * the given session. Also provides a mutation function to select a plan.
 *
 * @param sessionId - Onboarding session ID
 * @returns Payment plan data with loading/error states and selection function
 *
 * @example
 * function PaymentPlanSelector({ sessionId }) {
 *   const { paymentPlans, loading, error, selectPlan, selecting } = usePaymentPlans(sessionId);
 *
 *   if (loading) return <LoadingState />;
 *   if (error) return <ErrorState error={error} />;
 *   if (!paymentPlans) return <NoDataState />;
 *
 *   return (
 *     <div>
 *       {paymentPlans.map(plan => (
 *         <PlanCard
 *           key={plan.id}
 *           plan={plan}
 *           onSelect={() => selectPlan(plan.id)}
 *           selecting={selecting}
 *         />
 *       ))}
 *     </div>
 *   );
 * }
 */
export function usePaymentPlans(sessionId: string): UsePaymentPlansResult {
  // Execute GraphQL query for payment plans
  // Note: This will error until GraphQL schema is implemented
  // Uncomment when backend is ready:
  // const { data, loading, error, refetch } = useQuery(GET_PAYMENT_PLANS, {

  // Temporary mock structure for development
  const { data, loading, error, refetch } = useQuery(GET_PAYMENT_PLANS || {}, {
    skip: !GET_PAYMENT_PLANS || !sessionId, // Skip if query not available or no session ID
    variables: { sessionId },
    fetchPolicy: "cache-first", // Use cache for better performance
    errorPolicy: "all", // Return partial data on error
  });

  // Execute GraphQL mutation for selecting a payment plan
  const [setPaymentPreferenceMutation, { loading: selecting, error: selectError }] =
    useMutation(SET_PAYMENT_PREFERENCE || {});

  /**
   * Extract and transform payment plans from query response
   * Ensures type safety and handles missing data gracefully
   */
  const paymentPlans = useMemo<PaymentPlan[] | null>(() => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (!(data as any)?.getPaymentPlans) {
      return null;
    }

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (data as any).getPaymentPlans as PaymentPlan[];
  }, [data]);

  /**
   * Wrap refetch to handle potential errors
   */
  const handleRefetch = () => {
    try {
      refetch();
    } catch (err) {
      // Error will be captured in error state
      console.error("Failed to refetch payment plans:", err);
    }
  };

  /**
   * Select a payment plan by ID
   * Triggers mutation to update session with payment preference
   */
  const selectPlan = async (planId: string): Promise<void> => {
    if (!SET_PAYMENT_PREFERENCE) {
      console.warn("SetPaymentPreference mutation not available");
      return;
    }

    try {
      await setPaymentPreferenceMutation({
        variables: {
          sessionId,
          input: {
            preferenceType: "self_pay", // Payment plans are for self-pay
            paymentPlanId: planId,
          },
        },
        // Optimistically update cache
        optimisticResponse: {
          setPaymentPreference: {
            __typename: "SetPaymentPreferencePayload",
            success: true,
            session: {
              __typename: "OnboardingSession",
              id: sessionId,
              paymentPreference: {
                __typename: "PaymentPreference",
                preferenceType: "self_pay",
                paymentPlanId: planId,
              },
            },
          },
        },
      });
    } catch (err) {
      // Error will be captured in selectError state
      console.error("Failed to select payment plan:", err);
      throw err;
    }
  };

  return {
    paymentPlans,
    loading,
    error: error || null,
    refetch: handleRefetch,
    selectPlan,
    selecting,
    selectError: selectError || null,
  };
}
